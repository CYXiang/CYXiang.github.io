<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS底层探索(一) - 从零开始认识Clang与LLVM]]></title>
      <url>%2F2017%2F12%2F21%2FiOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E4%B8%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86Clang%E4%B8%8ELLVM%2F</url>
      <content type="text"><![CDATA[写在前面： 本系列为 『iOS底层探索系列』第一篇，本文源自本人的学习记录整理与理解，其中参考阅读了部分优秀的博客和书籍，尽量以通俗简单的语句转述。引用到的地方如有遗漏或未能一一列举原文出处还望见谅与指出，另，文章内容如有不妥之处还望指教。十分感谢。 入门起步从编译器说起 为什么需要编译？ 大家都知道，我们的计算机CPU只能读懂机器码（machine code，也就是由一堆0和1组成的编码）； 但我们现在编写的代码并不是机器码，而是高级编程语言（Objective-C、Swift、Java、…），最终也可以被计算机所执行， 这就需要编译了，在编译的过程中，编译器的作用便是把我们的高级编程语言通过一系列的操作转化成可被计算机执行的机器语言。ps：[更详细的解析可以自行百度] 编译器是如何设计的？ 经典的三段式设计（three phase design）:前端(Frontend)–优化器(Optimizer)–后端(Backend)（见下图） 其中前端负责分析源代码，可以检查语法级错误，并构建针对该语言的抽象语法树（AST） 抽象语法树可以进一步转换为优化，最终转为新的表示方式， 然后再交给让优化器和后端处理 最终由后端生成可执行的机器码 为什么要使用三段式设计？优势在哪？ 首先解决了一个很大的问题：假如有N种语言（C、OC、C++、Swift…）的前端，同时也有M个架构（模拟器、arm64、x86…）的Target，是否就需要 N × M 个编译器？ 三段式架构的价值就体现出来了，通过共享优化器的中转，很好的解决了这个问题。 假如你需要增加一种语言，只需要增加一种前端；假如你需要增加一种处理器架构，也只需要增加一种后端，而其他的地方都不需要改动。这复用思想很牛逼吧。(如下图) 编译源文件有哪些主要步骤？ 先列举一些整个编译过程的主要步骤，后面再详细介绍每个步骤都做了哪些事情。 主要编译步骤如下：12345671. 源代码（source code） -&gt; 2. 预处理器（preprocessor） -&gt; 3. 编译器（compiler） -&gt; 4. 汇编程序（assembler） -&gt; 5. 目标代码（object code） -&gt; 6. 链接器（Linker） -&gt; 7. 可执行文件（executables） Xcode编译器发展简史 Xcode3 以前： GCC；Xcode3： 增加LLVM，GCC(前端) + LLVM(后端)；Xcode4.2： 出现Clang - LLVM 3.0成为默认编译器；Xcode4.6： LLVM 升级到4.2版本；Xcode5： GCC被废弃，新的编译器是LLVM 5.0，从GCC过渡到Clang-LLVM的时代正式完成 为什么苹果的Xcode会使用Clang+LLVM取代GCC？ 这里面有些历史原因。毕竟GCC是第三方开源的，不属于苹果维护也不能完全掌控其开发进程，Apple为Objective-C增加许多新特性，但GCC开发者对这些支持却不友好；Apple需要做模块化，GCC开发者却拖着迟迟不实现。这能忍？ 随着Apple对其IDE(也就是Xcode)性能的要求越来越高，最终还是从零开发了一个Clang前端加LLVM后端的编译器，这个编译器的作者是大名鼎鼎的Swift之父Chris Lattner。 Clang比GCC优秀在哪些方面？ 传说新的Clang编译器编译Objective-C代码速度比GCC快3倍 并且提供了友好的代码提示 Clang 的简介 “Clang: a C language family frontend for LLVM” LLVM的C语言家族（C、C++、OC）前端。—- Clang 上面是官网对于Clang的一句话介绍，其实 Clang 就是上文所提到的编译器前端 用途：输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。 LLVM 的简介 LLVM ：顾名思义是（Low Level Virtual Machine）底层虚拟机？注意了，已经不是了！ 官网都说了：LLVM就是这个项目的全称，包含LLVM中介码（LLVM IR）、LLVM除错工具、LLVM C++标准库等一套工具，和传统底层虚拟机并没什么关系。 PS：下一篇将介绍Clang与LLVM的详细编译过程，欢迎关注。 附：我的github地址 参考文档http://clang.llvm.org/ http://www.aosabook.org/en/llvm.html http://history.programmer.com.cn/9436/ https://zh.wikipedia.org/wiki/Clang https://zh.wikipedia.org/wiki/LLVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编译器 clang 理解笔记]]></title>
      <url>%2F2017%2F12%2F17%2F%E7%BC%96%E8%AF%91%E5%99%A8-clang-%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[编译器 clang 理解笔记Xcode: GCC =&gt; GCC（前端） + LLVM(后端) =&gt; clang + LLVM (4.2) GDB=&gt;lldb Three-Phase 编译架构 三段式source =&gt; Fontend Optimizer Backend =&gt; machine code源代码 前端 优化器 后端 机器码 问题： M(Language) N(Target = MN Compilers N个语言的前端（C/C++/OC/Swift/..） 多个架构（模拟器/X86_64/RAM64/..） 有部分共享（优化器） 比如新增一种语言 只需要实现Swift Fontent就可以了，后面不需要动，就可以把Swift编译到各个架构 Clang + LLVM 代码规模 Total 400W C++ 235W Swift 代码规模 C++ 43W Apple 编译器 Clang-LLVM架构初识 你的源码是如何一步步成为可执行文件的？ 我们能用Clang做什么有意思的事情？ 点running以后做了什么？（跑脚本） 源文件的编译过程：1.在命令行中run一下以下脚本 这些参数是我们选的参数拼接 clang 后面拼接参数（-fobjic-arc/…） Clang 命令 Clang 在概念上是编译器前端，同时，在命令行中也作为一个 “黑盒” 的Driver 封装了编译管线、前端命令、LLVM命令、Toolchain命令等，一个Clang走天下 方便总GCC迁移过来 拆解过程 编译 main.m 过程 Preprocess - 预处理 $clang -E main.m import 头文件 （文本级别替换） macro 展开 （宏展开替换） 处理‘#’打头的预处理指令，如#if $clang -E fmodules main.m #import Foundatin =&gt; @import Foundatin 由于fmodules的出现，Xcode新建工程就不会默认创建.PCH 文件了 Lexical Analysis - 词法分析 $clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 词法分析，也作Lex或者Tokenization 将预处理过的代码文本转化为Token流 不校验语义 3.Semantic Analysis - 语法分析 ` $clang -fmodules -fsyntax-only -Xclang -ast-dump main.m` 语法分析，在Clang中由Parser和Sema两个模块配合完成 交验语法是否正确 根据当前语言的语法，生成语意节点，并将所有节点组合成抽象语法树（AST） 这一步跟源码等价，可以反写出源码 Static Analysis 静态分析 通过语法树进行代码静态分析，找出非语法性错误 模拟代码执行路径，分析出control-flow graph(CFG) 【MRC时代会分析出引用计数的错误】 预置了常用Checker（检查器） CodeGen - IR代码生成 CodeGen 负责将语法树丛顶至下遍历，翻译成LLVM IR LLVM IR 是Frontend的输出，也是LLVM Backend的输入，前后端的桥接语言 （Swift也是转成这个） 与 Objective-C Runtime 桥接 Class/Meta Class/Protocol/Category内存结构生成，并存放在指定section中（如Class：_DATA, _objc_classrefs） Method/lvar/Property内存结构生成 组成method_list/ivar_list/property_list并填入Class Non-Fragile ABI:为每个Ivar合成OBJCIVAR$_偏移值常量 存取Ivar的语句（_ivar = 123; int a = ivar;）转写成base + OBJCIVAR$_的形式 将语法树中的ObjcMessageExpr翻译成相应版本的objc_msgSend，对super关键字的调用翻译成objc_msgSendSuper 根据修饰符strong/weak/copy/atomic合成@property 自动实现的 setter/getter 处理@synthesize 生成block_layout的数据结构 变量的capture(block/weak) 生成_block_invoke函数 ARC：分析对象引用关系，将objc_storeStrong/objc_storeWeak等ARC代码插入 将ObjCAutoreleasePoolStmt转译成objc_autoreleasePoolPush/Pop 实现自动调用[super dealloc] 为每个拥有ivar的Class合成.cxx_destructor方法来自动释放类的成员变量，代替MRC时代的“self.xxx = nil” ![15134626439514.jpg](http://upload-images.jianshu.io/upload_images/620754-6ccde89af4339c9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) - Optimize - 优化IR 递归优化成伪递归 - LLVM Bitcode - 生成字节码 - Assemble - 生成Target相关汇编 Assemble - 生成Target相关Object(Mach-O) Link生成Executable 总结：Clang-LLVM下，一个源文件的编译过程 我们能用Clang做什么有意思的事情？LibClang C API来访问Clang的上层能力，如获取Tokens、遍历语法树、代码补全、获取诊断信息 API稳定，不受Clang源码更新影响 只有上层语法树访问，不能获取全部信息 如何使用 使用原始C API 脚本语言：使用官方提供的python binding或开源的node-js/ruby binding Objective-C: 开源库ClangKit LibClang - Demo 制作代码检查器 LibTooling- 对语法树有完全的控制权 - 可作为一个standalone 命令单独的使用，如clang-format - 需要使用C++且对Clang源码熟悉 - Demo 自动OC转Swift ClangPlugin 对语法树有完全的控制权 作为插件注入到编译流程中，可以影响build和决定编译过程 需要使用C++且对Clang源码熟悉 Demo （报警告，整顿代码风格） Clang-LLVM 相关资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建高效的Mac开发环境]]></title>
      <url>%2F2017%2F03%2F04%2F%E6%90%AD%E5%BB%BA%E9%AB%98%E6%95%88%E7%9A%84Mac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[最近换了新的MacBook，从新搭建了一个开发 命令行工具 oh my zsh安装##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UICollectionView基本使用详解]]></title>
      <url>%2F2017%2F02%2F28%2FUICollectionView%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[概述 UICollectionView是从iOS6开始引入使用的，目前应用非常广泛，很牛逼！老外的博客也是这么说的(传送门) 与UITableView的初步比较 UITableView应该是大家最熟悉的控件了，UICollectionView的使用与之类似，但又有所区别，如下介绍。相同点: 1.都是通过datasource和delegate驱动的(datasource和delegate官方文档传送)，因此在使用的时候必须实现数据源与代理协议方法; 2.性能上都实现了循环利用的优化。 不同点 1.UITableView的cell是系统自动布局好的，不需要我们布局。但UICollectionView的cell是需要我们自己布局的。所以我们在创建UICollectionView的时候必须传递一个布局参数，系统提供并实现了一个布局样式：流水布局(UICollectionViewFlowLayout)(流水布局官方文档传送)。 注：苹果关于FlowLayout的解析 2.UITableViewController的self.view == self.tableview;,但UICollectionViewController的self.view != self.collectionView； 3.UITableView的滚动方式只能是垂直方向， UICollectionView既可以垂直滚动，也可以水平滚动； 4.UICollectionView的cell只能通过注册来确定重用标识符。 结论: 换句话说，UITableView的布局是UICollectionView的flow layout布局的一种特殊情况，类比于同矩形与正方形的关系 下面简单介绍几个基本用法(难度从低到高) 1. UICollectionView普通用法（FlowLayout布局） 上面我们提到了UICollectionView与UITableView的用法非常类似，下面就让我们完全根据创建UITableView的方式来创建一个UICollectionView（请读者类比UITableView的创建方式，实现数据源，代理等，这里就只提到与之不同的方面，详细代码可参考示例Demo）。 报错了，提示缺少布局参数，如下： 解决报错，我们可以传FlowLayout参数方式，也可以重写内部init方法。我们这里采用重写init方法，传递布局参数。这样更加体现了封装的思想，把传递布局参数封装在CYXNormalCollectionViewController内，对外只提供统一的外部方法：init方法，代码如下： 123456789101112131415161718192021222324 - (instancetype)init&#123; // 设置流水布局 UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init]; // UICollectionViewFlowLayout流水布局的内部成员属性有以下： /** @property (nonatomic) CGFloat minimumLineSpacing; @property (nonatomic) CGFloat minimumInteritemSpacing; @property (nonatomic) CGSize itemSize; @property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); // defaults to CGSizeZero - setting a non-zero size enables cells that self-size via -preferredLayoutAttributesFittingAttributes: @property (nonatomic) UICollectionViewScrollDirection scrollDirection; // default is UICollectionViewScrollDirectionVertical @property (nonatomic) CGSize headerReferenceSize; @property (nonatomic) CGSize footerReferenceSize; @property (nonatomic) UIEdgeInsets sectionInset; */ // 定义大小 layout.itemSize = CGSizeMake(100, 100); // 设置最小行间距 layout.minimumLineSpacing = 2; // 设置垂直间距 layout.minimumInteritemSpacing = 2; // 设置滚动方向（默认垂直滚动） layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; return [self initWithCollectionViewLayout:layout];&#125; 这里我们使用xib自定义cell，通过xib注册cell的代码如下 12// 通过xib注册 [self.collectionView registerNib:[UINib nibWithNibName:NSStringFromClass([CYXNormalCell class]) bundle:nil] forCellWithReuseIdentifier:reuseIdentifier]; 初步效果图如下（这里就不详细实现了，剩下请读者参考UITableView的用法（请点这里）） 2. 新手引导页制作 简述 新手引导页，几乎是每个应用都有的，目的为了告诉用户应用的亮点，达到吸引用户的作用。 利用UICollectionView的优势（循环利用）实现新手引导页，既简单又高效，何乐而不为呢。 实现思路： 1.把UICollectionView的每个cell的尺寸设置为跟屏幕一样大； 1layout.itemSize = [UIScreen mainScreen].bounds.size; 2.设置为水平滚动方向，设置水平间距为0. 12345// 设置间距 layout.minimumLineSpacing = 0; layout.minimumInteritemSpacing = 0;// 设置滚动方向（默认垂直滚动） layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; 3.开启分页滚动模式 123456// 开启分页 self.collectionView.pagingEnabled = YES;// 隐藏水平滚动条 self.collectionView.showsHorizontalScrollIndicator = NO; // 取消弹簧效果 self.collectionView.bounces = NO; 以下是效果图： 实现详细步骤请参考示例代码：https://github.com/CYXiang/CYXTenMinDemo 3. 图片循环轮播器 请参考我之前的文章（内附代码）《iOS上机题（附个人见解）》 4. 带特效的图片浏览器（自定义布局/上） 以下内容分为两小节：1&gt; Github例子分析2&gt; 自己实现一个小Demo （1）Github例子分析 我们经常在Github上看到一些关于CollectionView的cell切换的炫酷效果，下面我们来分析一下Github上的这个卡片切换带3D动画Demo(RGCardViewLayout)&lt;地址请点&gt; 下面是效果图 目录结构分析：目录结构一目了然，关键在于有一个自动布局类（如图所示），这个类继承自UICollectionViewFlowLayout（我们可以猜到他使用的是默认的流水布局），并重写了- (void)prepareLayout、- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect等方法。我们试着把这个类里面的重载方法都注释掉，得到的效果跟普通用法的效果一样（这里就不截图了）。由此可见，作者肯定在这些方法内做了个性化的设置。 关键源码分析： 首先我们看到，作者在- (void)prepareLayout方法内做了对collectionView的初始化布局操作。因此我们可以断定重写此方法是用做初始化的（读者可以尝试修改，改变效果）。 1234567891011121314- (void)prepareLayout&#123; [super prepareLayout]; [self setupLayout]; // 初始化布局&#125;- (void)setupLayout&#123; CGFloat inset = self.collectionView.bounds.size.width * (6/64.0f); inset = floor(inset); self.itemSize = CGSizeMake(self.collectionView.bounds.size.width - (2 *inset), self.collectionView.bounds.size.height * 3/4); self.sectionInset = UIEdgeInsetsMake(0,inset, 0,inset); self.scrollDirection = UICollectionViewScrollDirectionHorizontal;&#125; 接着这个- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect方法应该是最重要的了，同理，我们先注释掉里面个性化的设置，只留[super layoutAttributesForElementsInRect:rect]，我们发现炫酷的3D效果没有了。因此可以断定此方法是给每个Cell做个性化设置的。 方法解析：这个方法的返回值是一个数组（数组里面存放着rect范围内所有元素的布局属性）这个方法的返回值决定了rect范围内所有元素的排布方式（frame）UICollectionViewLayoutAttributes *attrs; 1.一个cell对应一个UICollectionViewLayoutAttributes对象 2.UICollectionViewLayoutAttributes对象决定了cell的frame 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; // 获取父类(流水布局)已经计算好的布局，在这个基础上做个性化修改 NSArray *attributes = [super layoutAttributesForElementsInRect:rect]; NSArray *cellIndices = [self.collectionView indexPathsForVisibleItems]; if(cellIndices.count == 0 ) &#123; return attributes; &#125; else if (cellIndices.count == 1) &#123; mainIndexPath = cellIndices.firstObject; movingInIndexPath = nil; &#125; else if(cellIndices.count &gt; 1) &#123; NSIndexPath *firstIndexPath = cellIndices.firstObject; if(firstIndexPath == mainIndexPath) &#123; movingInIndexPath = cellIndices[1]; &#125; else &#123; movingInIndexPath = cellIndices.firstObject; mainIndexPath = cellIndices[1]; &#125; &#125; difference = self.collectionView.contentOffset.x - previousOffset; previousOffset = self.collectionView.contentOffset.x; // 关键代码：取每一个Cell的布局属性，并添加3D效果 for (UICollectionViewLayoutAttributes *attribute in attributes) &#123; [self applyTransformToLayoutAttributes:attribute]; &#125; return attributes;&#125;``` - 上面关键方法都已经实现了，但是运行发现并没有我们想要的效果，CollectionViewCell并没有实时发生形变。y因此我们还需要调用以下方法。&gt;方法解析：只要滚动屏幕 就会调用 方法 `-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect` 只要布局页面的属性发生改变 就会重新调用 `-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect` 这个方法```objc// indicate that we want to redraw as we scroll- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds &#123; return YES;&#125; （2）仿写Demo 经过上面对代码的分析，我们可以简单了解到自定义layout布局的基本实现，下面就可以仿写一个简单的Demo了，效果图如下。 参考代码如下（详细见Github） 12345678910111213141516171819202122232425262728293031323334353637383940- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125;- (void)prepareLayout&#123; [super prepareLayout]; self.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 设置内边距 CGFloat inset = (self.collectionView.frame.size.width - self.itemSize.width) * 0.5; self.sectionInset = UIEdgeInsetsMake(0, inset, 0, inset); &#125;- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; // 获得super已经计算好的布局属性 NSArray *attributes = [super layoutAttributesForElementsInRect:rect]; // 计算collectionView最中心点的x值 CGFloat centerX = self.collectionView.contentOffset.x + self.collectionView.frame.size.width * 0.5; // 在原有布局属性的基础上，进行微调 for (UICollectionViewLayoutAttributes *attrs in attributes) &#123; // cell的中心点x 和 collectionView最中心点的x值 的间距 CGFloat delta = ABS(attrs.center.x - centerX); // 根据间距值 计算 cell的缩放比例 CGFloat scale = 1.2 - delta / self.collectionView.frame.size.width; NSLog(@"%f,%f",delta,scale); // 设置缩放比例 attrs.transform = CGAffineTransformMakeScale(scale, scale); &#125; return attributes; &#125; 5.瀑布流布局（自定义布局/下） 瀑布流布局在很多应用中非常常见，效果图如下： 实现思路（简化） （1）继承自UICollectionViewLayout； （2）几个需要重载的方法： 12345678910111213141516/* * 初始化 */- (void)prepareLayout;/* * 返回rect中的所有的元素的布局属性 */- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect;/* * 返回对应于indexPath的位置的cell的布局属性 */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath；/* * 返回collectionView的内容的尺寸 */- (CGSize)collectionViewContentSize; 关键计算代码如下（详细见Github）123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 返回indexPath位置cell对应的布局属性 */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; // 创建布局属性 UICollectionViewLayoutAttributes *attrs = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; // collectionView的宽度 CGFloat collectionViewW = self.collectionView.frame.size.width; // 设置布局属性的frame CGFloat w = (collectionViewW - self.edgeInsets.left - self.edgeInsets.right - (self.columnCount - 1) * self.columnMargin) / self.columnCount; CGFloat h = [self.delegate waterflowLayout:self heightForItemAtIndex:indexPath.item itemWidth:w]; // 找出高度最短的那一列 NSInteger destColumn = 0; CGFloat minColumnHeight = [self.columnHeights[0] doubleValue]; for (NSInteger i = 1; i &lt; self.columnCount; i++) &#123; // 取得第i列的高度 CGFloat columnHeight = [self.columnHeights[i] doubleValue]; if (minColumnHeight &gt; columnHeight) &#123; minColumnHeight = columnHeight; destColumn = i; &#125; &#125; CGFloat x = self.edgeInsets.left + destColumn * (w + self.columnMargin); CGFloat y = minColumnHeight; if (y != self.edgeInsets.top) &#123; y += self.rowMargin; &#125; attrs.frame = CGRectMake(x, y, w, h); // 更新最短那列的高度 self.columnHeights[destColumn] = @(CGRectGetMaxY(attrs.frame)); // 记录内容的高度 CGFloat columnHeight = [self.columnHeights[destColumn] doubleValue]; if (self.contentHeight &lt; columnHeight) &#123; self.contentHeight = columnHeight; &#125; return attrs;&#125; 6. 布局切换 苹果已经为我们想好了布局切换的快捷方式，只需要通过以下方法，即可实现。 123- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated; // transition from one layout to another- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); 附： 源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS重构-轻量级的网络请求封装实践]]></title>
      <url>%2F2017%2F02%2F27%2FiOS%E9%87%8D%E6%9E%84-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言 在十分钟搭建主流框架_简单的网络部分(OC) 中，我们使用AFN框架顺利的发送网络请求并返回了有用数据，但对AFN框架的依赖十分严重，下面我们重构一下。 源码github地址 初步 很多时候，我们涉及到网络请求这块，都离不开几个第三方框架，AFNetworking，MJExtention, MBProgressHUD（SV）。 初学的时候，都会把它们写到Controller里面，如下: 123456789101112[[AFHTTPSessionManager manager] GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; NSLog(@"请求成功"); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@"result"]]; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData];&#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"请求失败 原因：%@",error);&#125;]; 这样会造成耦合性过高的问题，灵活性也非常不好，因此，AFN的作者也推荐我们不要直接使用，新建一个网络请求类来继承AFN的使用方式更好。 因此，继承的方式，如下： CYXHTTPSessionManager.h文件 123#import &lt;AFHTTPSessionManager.h&gt;@interface CYXHTTPSessionManager : AFHTTPSessionManager@end CYXHTTPSessionManager.m文件 12345678910 #import "CYXHTTPSessionManager.h" @implementation CYXHTTPSessionManager + (instancetype)manager&#123; CYXHTTPSessionManager *mgr = [super manager];// 这里可以做一些统一的配置// mgr.responseSerializer = ;// mgr.requestSerializer = ; return mgr; &#125; @end 调用方式： 123456789101112131415161718/** 请求管理者 */@property (nonatomic,weak) CYXHTTPSessionManager * manager; // 发送请求 [self.manager GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; // 存储 maxtime weakSelf.maxtime = responseObject[@"info"][@"maxtime"]; weakSelf.topics = [CYXTopic objectArrayWithKeyValuesArray:responseObject[@"list"]]; CYXLog(@"%@",responseObject[@"list"]); [weakSelf.tableView reloadData]; // 结束刷新 [weakSelf.tableView.header endRefreshing]; &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; [weakSelf.tableView.header endRefreshing]; &#125;]; 这样，已经降低了一点耦合度，也不需要在每个需要发送网络请求的Controller中引入AFN框架了。但对于MJExtension框架的依赖还是没有改善。 进阶 通过观察，我们发现其实大部分的GET和POST请求的前几步基本使用步骤是大致相同的，相同的步骤如下： 1.通过AFN请求回来JSON数据 2.通过JSON数据，取出需要使用的字典数组/字典 3.使用字典转模型框架（MJExtension）把字典数组转化为模型数组/字典转化为模型 因此，我们思考能不能把这些相同的步骤封装起来，以后就不需要重复写这些代码了，我们都知道一条经典的编程法则：“Don’t repeat youself”。这就是我们封装与重构的理由！ 1.基层请求的封装 本文示例封装POST请求 CYXHttpRequest.h文件 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import "AFNetworking.h"@interface CYXHttpRequest : NSObject/** * 发送一个POST请求 * * @param url 请求路径 * @param params 请求参数 * @param success 请求成功后的回调 * @param failure 请求失败后的回调 */+ (void)post:(NSString *)url params:(NSDictionary *)params success:(void (^)(id responseObj))success failure:(void (^)(NSError *error))failure;@end CYXHttpRequest.m文件 12345678910111213141516171819202122232425#import "CYXHttpRequest.h"@implementation CYXHttpRequest+ (void)post:(NSString *)url params:(NSDictionary *)params success:(void (^)(id))success failure:(void (^)(NSError *))failure&#123; // 1.获得请求管理者 AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager]; // 2.申明返回的结果是text/html类型 mgr.responseSerializer = [AFHTTPResponseSerializer serializer]; // 3.设置超时时间为10s mgr.requestSerializer.timeoutInterval = 10; // 4.发送POST请求 [mgr POST:url parameters:params progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; if (success) &#123; success(responseObject); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(error); &#125; &#125;];&#125;@end 现在已经可以把网络数据请求回来了，轮到第二个步骤了：观察请求回来的JSON数据，取出需要使用的字典数组/字典。在这里再作一层封装。举个简单的例子,假如返回的JSON数据结构如下: 1234567891011121314151617181920212223&#123; "error_code": 0, "reason": "Success", "result": [&#123; "id": 370622, "title": "西红柿蒜薹炒鸡蛋", "tags": "厨房用具;厨具;加工工艺;基本工艺;菜品;菜肴;家常菜;炒;炒锅;热菜;防辐射;开胃;蔬菜类;果实类;蒜薹;西红柿;禽蛋类;蛋;鸡蛋;", "intro": "我这的蒜薹鸡蛋都爱加西红柿、辣椒一起炒的，这是习惯所致，爱吃西红柿，爱吃辣椒，还爱把菜搭配的颜色亮丽，当然味道也不差。", "ingredients": "西红柿:1个;蒜薹:200g;鸡蛋:2个;", "burden": "油:适量;盐:适量;青辣椒:1个;红辣椒:1个;", "albums": "http://imgs.haoservice.com/CaiPu/pic/recipe/l/be/a7/370622_86e12b.jpg", &#125; &#123; "id": 433079, "title": "西红柿酸奶", "tags": "促进食欲;减肥;懒人食谱;消暑食谱;美容养颜;", "intro": "新疆人爱吃西红柿那是有目共睹的，菜里面加西红柿的数不胜数，就连舌尖2在吐鲁番拍的葡萄干抓饭里面都加西红柿。", "ingredients": "酸奶:400g;西红柿:200g;", "burden": "白糖:20g;", "albums": "http://imgs.haoservice.com/CaiPu/pic/recipe/l/b7/9b/433079_377373.jpg", &#125; &#123;···&#125;]&#125; 2.简单业务逻辑封装 现在只需要使用到result数据（并对应CYXMenu模型），在公司中，接口一般会有比较好的规范，即每个接口的模型属性一般都有统一的命名。 我们使用时，通常会把result字典数组转化成CYXMenu模型数组。因此，可以进一步的封装出CYXBaseRequest对象。 CYXBaseRequest类实现思路如下： 1.使用CYXHttpRequest发起网络请求，返回数据中取到result 2.使用MJExtension将result字典数组转化成CYXMenu模型数组，并返回模型数组 3.外界只需要传递进来一个resultClass即可。 CYXBaseRequest实现代码如下： CYXBaseRequest.h文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;@interface CYXBaseRequest : NSObject/** * 返回result 数据模型 * * @param url 请求地址 * @param param 请求参数 * @param resultClass 需要转换返回的数据模型 * @param success 请求成功后的回调 * @param warn 请求失败后警告提示语 * @param failure 请求失败后的回调 * @param tokenInvalid token过期后的回调 */+ (void)postResultWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid;/** * 返回result 数据模型（带HUD） * * @param url 请求地址 * @param param 请求参数 * @param resultClass 需要转换返回的数据模型 * @param success 请求成功后的回调 * @param warn 请求失败后警告提示语 * @param failure 请求失败后的回调 * @param tokenInvalid token过期后的回调 */+ (void)postResultHUDWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid;/** * 组合请求参数 * * @param dict 外部参数字典 * * @return 返回组合参数 */+ (NSMutableDictionary *)requestParams:(NSDictionary *)dict;@end CYXBaseRequest.m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import "CYXBaseRequest.h"#import "CYXHttpRequest.h"#import "ExceptionMsgTips.h"#import "MJExtension.h"@implementation BSBaseRequest/** * 返回result 数据模型（HUD） */+ (void)postResultHUDWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123; [self postBaseHUDWithUrl:url param:param resultClass:resultClass success:^(id responseObj) &#123; if (!resultClass) &#123; success(nil); return; &#125; success([resultClass mj_objectArrayWithKeyValuesArray:responseObj[@"result"]]); &#125; warn:warn failure:failure tokenInvalid:tokenInvalid];&#125;/** * 返回result 数据模型 */+ (void)postResultWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123; [self postBaseWithUrl:url param:param resultClass:resultClass success:^(id responseObj) &#123; if (!resultClass) &#123; success(nil); return; &#125; success([resultClass mj_objectArrayWithKeyValuesArray:responseObj[@"result"]]); &#125; warn:warn failure:failure tokenInvalid:tokenInvalid];&#125;/** * 数据模型基类方法 */+ (void)postBaseWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123;// url = [NSString stringWithFormat:@"%@%@",Host,url]; CYXLog(@"\\n请求链接地址---&gt; %@",url); //状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = YES; [CYXHttpRequest post:url params:param success:^(id responseObj) &#123; if (success) &#123; NSDictionary *dictData = [NSJSONSerialization JSONObjectWithData:responseObj options:kNilOptions error:nil]; CYXLog(@"请求成功，返回数据 : %@",dictData); success(dictData); &#125; //状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; &#125; failure:^(NSError *error) &#123; if (failure) &#123; failure(error); CYXLog(@"请求失败：%@",error); &#125; //状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; &#125;];&#125;/** * 数据模型基类(带HUD) */+ (void)postBaseHUDWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123; [SVProgressHUD showWithStatus:@""]; [self postBaseWithUrl:url param:param resultClass:resultClass success:^(id responseObj) &#123; [SVProgressHUD dismiss]; //隐藏loading success(responseObj); &#125; warn:^(NSString *warnMsg) &#123; [SVProgressHUD dismiss]; warn(warnMsg); &#125; failure:^(NSError *fail) &#123; [SVProgressHUD dismiss]; failure(fail); &#125; tokenInvalid:^&#123; [SVProgressHUD dismiss]; tokenInvalid(); &#125;];&#125;@end 到这里，轻量级的封装介绍已经全部介绍完了，更多的功能封装有待读者自己去研究了。既然封装好了，下面我们来介绍一下如何使用，其实非常简单。 使用介绍 1.把上述两个类的.h .m 文化拖到您项目中，最好新建一个文件夹。 2.在需要发送请求的Controller中#import &quot;CYXBaseRequest.h&quot; 3.发送请求方法中的代码如下： （使用CYXBaseRequest）： 12345678910111213141516171819202122232425#pragma mark - 请求数据方法- (void)loadData&#123; self.pn = 1; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @(self.pn); params[@"rn"] = @"10"; params[@"key"] = @"fcfdb87c50c1485e9e7fa9f839c4b1a8"; [CYXBaseRequest postResultWithUrl:CYXRequestURL param:params resultClass:[CYXMenu class] success:^(id result) &#123; CYXLog(@"请求成功，返回数据 : %@",result); self.menus = result; self.pn ++; // 刷新数据（若不刷新数据会显示不出） [self.tableView reloadData]; [self.tableView.mj_header endRefreshing]; &#125; warn:^(NSString *warnMsg) &#123; &#125; failure:^(NSError *error) &#123; CYXLog(@"请求失败 原因：%@",error); [self.tableView.mj_header endRefreshing]; &#125; tokenInvalid:^&#123; // 有登录操作的业务，这里返回登录状态 &#125;];&#125; 在这里对比一下不使用CYXBaseRequest的发送请求方法代码： 1234567891011121314151617181920212223242526#pragma mark - 请求数据方法- (void)loadData&#123; self.pn = 1; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @(self.pn); params[@"rn"] = @"10"; params[@"key"] = @"fcfdb87c50c1485e9e7fa9f839c4b1a8"; [self.manager.tasks makeObjectsPerformSelector:@selector(cancel)]; [self.manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObject:@"text/html"]]; [self.manager POST:CYXRequestURL parameters:params progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; CYXLog(@"请求成功，返回数据 : %@",responseObject); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu mj_objectArrayWithKeyValuesArray:responseObject[@"result"]]; weakSelf.pn ++; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData]; [weakSelf.tableView.mj_header endRefreshing]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; CYXLog(@"请求失败 原因：%@",error); [weakSelf.tableView.mj_header endRefreshing]; &#125;];&#125; 虽然从代码看似两种使用差别不太大（只是少了几行代码），但相比之下，前者确实降低了对AFN等框架的依赖，并省去了每次都手动转一下模型的烦恼，现在你只需要把resultClass传过去，返回的数据便是已经转化好的模型，并在CYXBaseRequest内打印出请求链接地址，返回数据等有用信息，方便调试，接口设计也类似AFN，使用简便。 TIPS:建议使用者可以在每个模块都建立Request文件（继承CYXBaseRequest），统一进行网络请求，这样更方便管理。 注： 本封装实践只对网络请求进行初步的简单封装，仅适用于中小型的项目，并不涉及缓存、校验等高级功能，如果有高级需求，建议研究下猿题库的YTKNetwork网络库。 附：源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F27%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
