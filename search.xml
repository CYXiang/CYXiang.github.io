<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS底层探索(一) - 从零开始认识Clang与LLVM]]></title>
      <url>%2F2017%2F12%2F21%2FiOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E4%B8%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86Clang%E4%B8%8ELLVM%2F</url>
      <content type="text"><![CDATA[写在前面： 本系列为 『iOS底层探索系列』第一篇，本文源自本人的学习记录整理与理解，其中参考阅读了部分优秀的博客和书籍，尽量以通俗简单的语句转述。引用到的地方如有遗漏或未能一一列举原文出处还望见谅与指出，另，文章内容如有不妥之处还望指教。十分感谢。 入门起步从编译器说起 为什么需要编译？ 大家都知道，我们的计算机CPU只能读懂机器码（machine code，也就是由一堆0和1组成的编码）； 但我们现在编写的代码并不是机器码，而是高级编程语言（Objective-C、Swift、Java、…），最终也可以被计算机所执行， 这就需要编译了，在编译的过程中，编译器的作用便是把我们的高级编程语言通过一系列的操作转化成可被计算机执行的机器语言。ps：[更详细的解析可以自行百度] 编译器是如何设计的？ 经典的三段式设计（three phase design）:前端(Frontend)–优化器(Optimizer)–后端(Backend)（见下图） 其中前端负责分析源代码，可以检查语法级错误，并构建针对该语言的抽象语法树（AST） 抽象语法树可以进一步转换为优化，最终转为新的表示方式， 然后再交给让优化器和后端处理 最终由后端生成可执行的机器码 为什么要使用三段式设计？优势在哪？ 首先解决了一个很大的问题：假如有N种语言（C、OC、C++、Swift…）的前端，同时也有M个架构（模拟器、arm64、x86…）的Target，是否就需要 N × M 个编译器？ 三段式架构的价值就体现出来了，通过共享优化器的中转，很好的解决了这个问题。 假如你需要增加一种语言，只需要增加一种前端；假如你需要增加一种处理器架构，也只需要增加一种后端，而其他的地方都不需要改动。这复用思想很牛逼吧。(如下图) 编译源文件有哪些主要步骤？ 先列举一些整个编译过程的主要步骤，后面再详细介绍每个步骤都做了哪些事情。 主要编译步骤如下：12345671. 源代码（source code） -&gt; 2. 预处理器（preprocessor） -&gt; 3. 编译器（compiler） -&gt; 4. 汇编程序（assembler） -&gt; 5. 目标代码（object code） -&gt; 6. 链接器（Linker） -&gt; 7. 可执行文件（executables） Xcode编译器发展简史 Xcode3 以前： GCC；Xcode3： 增加LLVM，GCC(前端) + LLVM(后端)；Xcode4.2： 出现Clang - LLVM 3.0成为默认编译器；Xcode4.6： LLVM 升级到4.2版本；Xcode5： GCC被废弃，新的编译器是LLVM 5.0，从GCC过渡到Clang-LLVM的时代正式完成 为什么苹果的Xcode会使用Clang+LLVM取代GCC？ 这里面有些历史原因。毕竟GCC是第三方开源的，不属于苹果维护也不能完全掌控其开发进程，Apple为Objective-C增加许多新特性，但GCC开发者对这些支持却不友好；Apple需要做模块化，GCC开发者却拖着迟迟不实现。这能忍？ 随着Apple对其IDE(也就是Xcode)性能的要求越来越高，最终还是从零开发了一个Clang前端加LLVM后端的编译器，这个编译器的作者是大名鼎鼎的Swift之父Chris Lattner。 Clang比GCC优秀在哪些方面？ 传说新的Clang编译器编译Objective-C代码速度比GCC快3倍 并且提供了友好的代码提示 Clang 的简介 “Clang: a C language family frontend for LLVM” LLVM的C语言家族（C、C++、OC）前端。—- Clang 上面是官网对于Clang的一句话介绍，其实 Clang 就是上文所提到的编译器前端 用途：输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。 LLVM 的简介 LLVM ：顾名思义是（Low Level Virtual Machine）底层虚拟机？注意了，已经不是了！ 官网都说了：LLVM就是这个项目的全称，包含LLVM中介码（LLVM IR）、LLVM除错工具、LLVM C++标准库等一套工具，和传统底层虚拟机并没什么关系。 PS：下一篇将介绍Clang与LLVM的详细编译过程，欢迎关注。 附：我的github地址 参考文档http://clang.llvm.org/ http://www.aosabook.org/en/llvm.html http://history.programmer.com.cn/9436/ https://zh.wikipedia.org/wiki/Clang https://zh.wikipedia.org/wiki/LLVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UICollectionView基本使用详解]]></title>
      <url>%2F2017%2F02%2F28%2FUICollectionView%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[概述 UICollectionView是从iOS6开始引入使用的，目前应用非常广泛，很牛逼！老外的博客也是这么说的(传送门) 与UITableView的初步比较 UITableView应该是大家最熟悉的控件了，UICollectionView的使用与之类似，但又有所区别，如下介绍。相同点: 1.都是通过datasource和delegate驱动的(datasource和delegate官方文档传送)，因此在使用的时候必须实现数据源与代理协议方法; 2.性能上都实现了循环利用的优化。 不同点 1.UITableView的cell是系统自动布局好的，不需要我们布局。但UICollectionView的cell是需要我们自己布局的。所以我们在创建UICollectionView的时候必须传递一个布局参数，系统提供并实现了一个布局样式：流水布局(UICollectionViewFlowLayout)(流水布局官方文档传送)。 注：苹果关于FlowLayout的解析 2.UITableViewController的self.view == self.tableview;,但UICollectionViewController的self.view != self.collectionView； 3.UITableView的滚动方式只能是垂直方向， UICollectionView既可以垂直滚动，也可以水平滚动； 4.UICollectionView的cell只能通过注册来确定重用标识符。 结论: 换句话说，UITableView的布局是UICollectionView的flow layout布局的一种特殊情况，类比于同矩形与正方形的关系 下面简单介绍几个基本用法(难度从低到高) 1. UICollectionView普通用法（FlowLayout布局） 上面我们提到了UICollectionView与UITableView的用法非常类似，下面就让我们完全根据创建UITableView的方式来创建一个UICollectionView（请读者类比UITableView的创建方式，实现数据源，代理等，这里就只提到与之不同的方面，详细代码可参考示例Demo）。 报错了，提示缺少布局参数，如下： 解决报错，我们可以传FlowLayout参数方式，也可以重写内部init方法。我们这里采用重写init方法，传递布局参数。这样更加体现了封装的思想，把传递布局参数封装在CYXNormalCollectionViewController内，对外只提供统一的外部方法：init方法，代码如下： 123456789101112131415161718192021222324 - (instancetype)init&#123; // 设置流水布局 UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init]; // UICollectionViewFlowLayout流水布局的内部成员属性有以下： /** @property (nonatomic) CGFloat minimumLineSpacing; @property (nonatomic) CGFloat minimumInteritemSpacing; @property (nonatomic) CGSize itemSize; @property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); // defaults to CGSizeZero - setting a non-zero size enables cells that self-size via -preferredLayoutAttributesFittingAttributes: @property (nonatomic) UICollectionViewScrollDirection scrollDirection; // default is UICollectionViewScrollDirectionVertical @property (nonatomic) CGSize headerReferenceSize; @property (nonatomic) CGSize footerReferenceSize; @property (nonatomic) UIEdgeInsets sectionInset; */ // 定义大小 layout.itemSize = CGSizeMake(100, 100); // 设置最小行间距 layout.minimumLineSpacing = 2; // 设置垂直间距 layout.minimumInteritemSpacing = 2; // 设置滚动方向（默认垂直滚动） layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; return [self initWithCollectionViewLayout:layout];&#125; 这里我们使用xib自定义cell，通过xib注册cell的代码如下 12// 通过xib注册 [self.collectionView registerNib:[UINib nibWithNibName:NSStringFromClass([CYXNormalCell class]) bundle:nil] forCellWithReuseIdentifier:reuseIdentifier]; 初步效果图如下（这里就不详细实现了，剩下请读者参考UITableView的用法（请点这里）） 2. 新手引导页制作 简述 新手引导页，几乎是每个应用都有的，目的为了告诉用户应用的亮点，达到吸引用户的作用。 利用UICollectionView的优势（循环利用）实现新手引导页，既简单又高效，何乐而不为呢。 实现思路： 1.把UICollectionView的每个cell的尺寸设置为跟屏幕一样大； 1layout.itemSize = [UIScreen mainScreen].bounds.size; 2.设置为水平滚动方向，设置水平间距为0. 12345// 设置间距 layout.minimumLineSpacing = 0; layout.minimumInteritemSpacing = 0;// 设置滚动方向（默认垂直滚动） layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; 3.开启分页滚动模式 123456// 开启分页 self.collectionView.pagingEnabled = YES;// 隐藏水平滚动条 self.collectionView.showsHorizontalScrollIndicator = NO; // 取消弹簧效果 self.collectionView.bounces = NO; 以下是效果图： 实现详细步骤请参考示例代码：https://github.com/CYXiang/CYXTenMinDemo 3. 图片循环轮播器 请参考我之前的文章（内附代码）《iOS上机题（附个人见解）》 4. 带特效的图片浏览器（自定义布局/上） 以下内容分为两小节：1&gt; Github例子分析2&gt; 自己实现一个小Demo （1）Github例子分析 我们经常在Github上看到一些关于CollectionView的cell切换的炫酷效果，下面我们来分析一下Github上的这个卡片切换带3D动画Demo(RGCardViewLayout)&lt;地址请点&gt; 下面是效果图 目录结构分析：目录结构一目了然，关键在于有一个自动布局类（如图所示），这个类继承自UICollectionViewFlowLayout（我们可以猜到他使用的是默认的流水布局），并重写了- (void)prepareLayout、- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect等方法。我们试着把这个类里面的重载方法都注释掉，得到的效果跟普通用法的效果一样（这里就不截图了）。由此可见，作者肯定在这些方法内做了个性化的设置。 关键源码分析： 首先我们看到，作者在- (void)prepareLayout方法内做了对collectionView的初始化布局操作。因此我们可以断定重写此方法是用做初始化的（读者可以尝试修改，改变效果）。 1234567891011121314- (void)prepareLayout&#123; [super prepareLayout]; [self setupLayout]; // 初始化布局&#125;- (void)setupLayout&#123; CGFloat inset = self.collectionView.bounds.size.width * (6/64.0f); inset = floor(inset); self.itemSize = CGSizeMake(self.collectionView.bounds.size.width - (2 *inset), self.collectionView.bounds.size.height * 3/4); self.sectionInset = UIEdgeInsetsMake(0,inset, 0,inset); self.scrollDirection = UICollectionViewScrollDirectionHorizontal;&#125; 接着这个- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect方法应该是最重要的了，同理，我们先注释掉里面个性化的设置，只留[super layoutAttributesForElementsInRect:rect]，我们发现炫酷的3D效果没有了。因此可以断定此方法是给每个Cell做个性化设置的。 方法解析：这个方法的返回值是一个数组（数组里面存放着rect范围内所有元素的布局属性）这个方法的返回值决定了rect范围内所有元素的排布方式（frame）UICollectionViewLayoutAttributes *attrs; 1.一个cell对应一个UICollectionViewLayoutAttributes对象 2.UICollectionViewLayoutAttributes对象决定了cell的frame 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; // 获取父类(流水布局)已经计算好的布局，在这个基础上做个性化修改 NSArray *attributes = [super layoutAttributesForElementsInRect:rect]; NSArray *cellIndices = [self.collectionView indexPathsForVisibleItems]; if(cellIndices.count == 0 ) &#123; return attributes; &#125; else if (cellIndices.count == 1) &#123; mainIndexPath = cellIndices.firstObject; movingInIndexPath = nil; &#125; else if(cellIndices.count &gt; 1) &#123; NSIndexPath *firstIndexPath = cellIndices.firstObject; if(firstIndexPath == mainIndexPath) &#123; movingInIndexPath = cellIndices[1]; &#125; else &#123; movingInIndexPath = cellIndices.firstObject; mainIndexPath = cellIndices[1]; &#125; &#125; difference = self.collectionView.contentOffset.x - previousOffset; previousOffset = self.collectionView.contentOffset.x; // 关键代码：取每一个Cell的布局属性，并添加3D效果 for (UICollectionViewLayoutAttributes *attribute in attributes) &#123; [self applyTransformToLayoutAttributes:attribute]; &#125; return attributes;&#125;``` - 上面关键方法都已经实现了，但是运行发现并没有我们想要的效果，CollectionViewCell并没有实时发生形变。y因此我们还需要调用以下方法。&gt;方法解析：只要滚动屏幕 就会调用 方法 `-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect` 只要布局页面的属性发生改变 就会重新调用 `-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect` 这个方法```objc// indicate that we want to redraw as we scroll- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds &#123; return YES;&#125; （2）仿写Demo 经过上面对代码的分析，我们可以简单了解到自定义layout布局的基本实现，下面就可以仿写一个简单的Demo了，效果图如下。 参考代码如下（详细见Github） 12345678910111213141516171819202122232425262728293031323334353637383940- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125;- (void)prepareLayout&#123; [super prepareLayout]; self.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 设置内边距 CGFloat inset = (self.collectionView.frame.size.width - self.itemSize.width) * 0.5; self.sectionInset = UIEdgeInsetsMake(0, inset, 0, inset); &#125;- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; // 获得super已经计算好的布局属性 NSArray *attributes = [super layoutAttributesForElementsInRect:rect]; // 计算collectionView最中心点的x值 CGFloat centerX = self.collectionView.contentOffset.x + self.collectionView.frame.size.width * 0.5; // 在原有布局属性的基础上，进行微调 for (UICollectionViewLayoutAttributes *attrs in attributes) &#123; // cell的中心点x 和 collectionView最中心点的x值 的间距 CGFloat delta = ABS(attrs.center.x - centerX); // 根据间距值 计算 cell的缩放比例 CGFloat scale = 1.2 - delta / self.collectionView.frame.size.width; NSLog(@"%f,%f",delta,scale); // 设置缩放比例 attrs.transform = CGAffineTransformMakeScale(scale, scale); &#125; return attributes; &#125; 5.瀑布流布局（自定义布局/下） 瀑布流布局在很多应用中非常常见，效果图如下： 实现思路（简化） （1）继承自UICollectionViewLayout； （2）几个需要重载的方法： 12345678910111213141516/* * 初始化 */- (void)prepareLayout;/* * 返回rect中的所有的元素的布局属性 */- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect;/* * 返回对应于indexPath的位置的cell的布局属性 */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath；/* * 返回collectionView的内容的尺寸 */- (CGSize)collectionViewContentSize; 关键计算代码如下（详细见Github）123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 返回indexPath位置cell对应的布局属性 */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; // 创建布局属性 UICollectionViewLayoutAttributes *attrs = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; // collectionView的宽度 CGFloat collectionViewW = self.collectionView.frame.size.width; // 设置布局属性的frame CGFloat w = (collectionViewW - self.edgeInsets.left - self.edgeInsets.right - (self.columnCount - 1) * self.columnMargin) / self.columnCount; CGFloat h = [self.delegate waterflowLayout:self heightForItemAtIndex:indexPath.item itemWidth:w]; // 找出高度最短的那一列 NSInteger destColumn = 0; CGFloat minColumnHeight = [self.columnHeights[0] doubleValue]; for (NSInteger i = 1; i &lt; self.columnCount; i++) &#123; // 取得第i列的高度 CGFloat columnHeight = [self.columnHeights[i] doubleValue]; if (minColumnHeight &gt; columnHeight) &#123; minColumnHeight = columnHeight; destColumn = i; &#125; &#125; CGFloat x = self.edgeInsets.left + destColumn * (w + self.columnMargin); CGFloat y = minColumnHeight; if (y != self.edgeInsets.top) &#123; y += self.rowMargin; &#125; attrs.frame = CGRectMake(x, y, w, h); // 更新最短那列的高度 self.columnHeights[destColumn] = @(CGRectGetMaxY(attrs.frame)); // 记录内容的高度 CGFloat columnHeight = [self.columnHeights[destColumn] doubleValue]; if (self.contentHeight &lt; columnHeight) &#123; self.contentHeight = columnHeight; &#125; return attrs;&#125; 6. 布局切换 苹果已经为我们想好了布局切换的快捷方式，只需要通过以下方法，即可实现。 123- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated; // transition from one layout to another- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); 附： 源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS重构-轻量级的网络请求封装实践]]></title>
      <url>%2F2017%2F02%2F27%2FiOS%E9%87%8D%E6%9E%84-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言 在十分钟搭建主流框架_简单的网络部分(OC) 中，我们使用AFN框架顺利的发送网络请求并返回了有用数据，但对AFN框架的依赖十分严重，下面我们重构一下。 源码github地址 初步 很多时候，我们涉及到网络请求这块，都离不开几个第三方框架，AFNetworking，MJExtention, MBProgressHUD（SV）。 初学的时候，都会把它们写到Controller里面，如下: 123456789101112[[AFHTTPSessionManager manager] GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; NSLog(@"请求成功"); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@"result"]]; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData];&#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"请求失败 原因：%@",error);&#125;]; 这样会造成耦合性过高的问题，灵活性也非常不好，因此，AFN的作者也推荐我们不要直接使用，新建一个网络请求类来继承AFN的使用方式更好。 因此，继承的方式，如下： CYXHTTPSessionManager.h文件 123#import &lt;AFHTTPSessionManager.h&gt;@interface CYXHTTPSessionManager : AFHTTPSessionManager@end CYXHTTPSessionManager.m文件 12345678910 #import "CYXHTTPSessionManager.h" @implementation CYXHTTPSessionManager + (instancetype)manager&#123; CYXHTTPSessionManager *mgr = [super manager];// 这里可以做一些统一的配置// mgr.responseSerializer = ;// mgr.requestSerializer = ; return mgr; &#125; @end 调用方式： 123456789101112131415161718/** 请求管理者 */@property (nonatomic,weak) CYXHTTPSessionManager * manager; // 发送请求 [self.manager GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; // 存储 maxtime weakSelf.maxtime = responseObject[@"info"][@"maxtime"]; weakSelf.topics = [CYXTopic objectArrayWithKeyValuesArray:responseObject[@"list"]]; CYXLog(@"%@",responseObject[@"list"]); [weakSelf.tableView reloadData]; // 结束刷新 [weakSelf.tableView.header endRefreshing]; &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; [weakSelf.tableView.header endRefreshing]; &#125;]; 这样，已经降低了一点耦合度，也不需要在每个需要发送网络请求的Controller中引入AFN框架了。但对于MJExtension框架的依赖还是没有改善。 进阶 通过观察，我们发现其实大部分的GET和POST请求的前几步基本使用步骤是大致相同的，相同的步骤如下： 1.通过AFN请求回来JSON数据 2.通过JSON数据，取出需要使用的字典数组/字典 3.使用字典转模型框架（MJExtension）把字典数组转化为模型数组/字典转化为模型 因此，我们思考能不能把这些相同的步骤封装起来，以后就不需要重复写这些代码了，我们都知道一条经典的编程法则：“Don’t repeat youself”。这就是我们封装与重构的理由！ 1.基层请求的封装 本文示例封装POST请求 CYXHttpRequest.h文件 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import "AFNetworking.h"@interface CYXHttpRequest : NSObject/** * 发送一个POST请求 * * @param url 请求路径 * @param params 请求参数 * @param success 请求成功后的回调 * @param failure 请求失败后的回调 */+ (void)post:(NSString *)url params:(NSDictionary *)params success:(void (^)(id responseObj))success failure:(void (^)(NSError *error))failure;@end CYXHttpRequest.m文件 12345678910111213141516171819202122232425#import "CYXHttpRequest.h"@implementation CYXHttpRequest+ (void)post:(NSString *)url params:(NSDictionary *)params success:(void (^)(id))success failure:(void (^)(NSError *))failure&#123; // 1.获得请求管理者 AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager]; // 2.申明返回的结果是text/html类型 mgr.responseSerializer = [AFHTTPResponseSerializer serializer]; // 3.设置超时时间为10s mgr.requestSerializer.timeoutInterval = 10; // 4.发送POST请求 [mgr POST:url parameters:params progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; if (success) &#123; success(responseObject); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(error); &#125; &#125;];&#125;@end 现在已经可以把网络数据请求回来了，轮到第二个步骤了：观察请求回来的JSON数据，取出需要使用的字典数组/字典。在这里再作一层封装。举个简单的例子,假如返回的JSON数据结构如下: 1234567891011121314151617181920212223&#123; "error_code": 0, "reason": "Success", "result": [&#123; "id": 370622, "title": "西红柿蒜薹炒鸡蛋", "tags": "厨房用具;厨具;加工工艺;基本工艺;菜品;菜肴;家常菜;炒;炒锅;热菜;防辐射;开胃;蔬菜类;果实类;蒜薹;西红柿;禽蛋类;蛋;鸡蛋;", "intro": "我这的蒜薹鸡蛋都爱加西红柿、辣椒一起炒的，这是习惯所致，爱吃西红柿，爱吃辣椒，还爱把菜搭配的颜色亮丽，当然味道也不差。", "ingredients": "西红柿:1个;蒜薹:200g;鸡蛋:2个;", "burden": "油:适量;盐:适量;青辣椒:1个;红辣椒:1个;", "albums": "http://imgs.haoservice.com/CaiPu/pic/recipe/l/be/a7/370622_86e12b.jpg", &#125; &#123; "id": 433079, "title": "西红柿酸奶", "tags": "促进食欲;减肥;懒人食谱;消暑食谱;美容养颜;", "intro": "新疆人爱吃西红柿那是有目共睹的，菜里面加西红柿的数不胜数，就连舌尖2在吐鲁番拍的葡萄干抓饭里面都加西红柿。", "ingredients": "酸奶:400g;西红柿:200g;", "burden": "白糖:20g;", "albums": "http://imgs.haoservice.com/CaiPu/pic/recipe/l/b7/9b/433079_377373.jpg", &#125; &#123;···&#125;]&#125; 2.简单业务逻辑封装 现在只需要使用到result数据（并对应CYXMenu模型），在公司中，接口一般会有比较好的规范，即每个接口的模型属性一般都有统一的命名。 我们使用时，通常会把result字典数组转化成CYXMenu模型数组。因此，可以进一步的封装出CYXBaseRequest对象。 CYXBaseRequest类实现思路如下： 1.使用CYXHttpRequest发起网络请求，返回数据中取到result 2.使用MJExtension将result字典数组转化成CYXMenu模型数组，并返回模型数组 3.外界只需要传递进来一个resultClass即可。 CYXBaseRequest实现代码如下： CYXBaseRequest.h文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;@interface CYXBaseRequest : NSObject/** * 返回result 数据模型 * * @param url 请求地址 * @param param 请求参数 * @param resultClass 需要转换返回的数据模型 * @param success 请求成功后的回调 * @param warn 请求失败后警告提示语 * @param failure 请求失败后的回调 * @param tokenInvalid token过期后的回调 */+ (void)postResultWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid;/** * 返回result 数据模型（带HUD） * * @param url 请求地址 * @param param 请求参数 * @param resultClass 需要转换返回的数据模型 * @param success 请求成功后的回调 * @param warn 请求失败后警告提示语 * @param failure 请求失败后的回调 * @param tokenInvalid token过期后的回调 */+ (void)postResultHUDWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid;/** * 组合请求参数 * * @param dict 外部参数字典 * * @return 返回组合参数 */+ (NSMutableDictionary *)requestParams:(NSDictionary *)dict;@end CYXBaseRequest.m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import "CYXBaseRequest.h"#import "CYXHttpRequest.h"#import "ExceptionMsgTips.h"#import "MJExtension.h"@implementation BSBaseRequest/** * 返回result 数据模型（HUD） */+ (void)postResultHUDWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123; [self postBaseHUDWithUrl:url param:param resultClass:resultClass success:^(id responseObj) &#123; if (!resultClass) &#123; success(nil); return; &#125; success([resultClass mj_objectArrayWithKeyValuesArray:responseObj[@"result"]]); &#125; warn:warn failure:failure tokenInvalid:tokenInvalid];&#125;/** * 返回result 数据模型 */+ (void)postResultWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123; [self postBaseWithUrl:url param:param resultClass:resultClass success:^(id responseObj) &#123; if (!resultClass) &#123; success(nil); return; &#125; success([resultClass mj_objectArrayWithKeyValuesArray:responseObj[@"result"]]); &#125; warn:warn failure:failure tokenInvalid:tokenInvalid];&#125;/** * 数据模型基类方法 */+ (void)postBaseWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123;// url = [NSString stringWithFormat:@"%@%@",Host,url]; CYXLog(@"\\n请求链接地址---&gt; %@",url); //状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = YES; [CYXHttpRequest post:url params:param success:^(id responseObj) &#123; if (success) &#123; NSDictionary *dictData = [NSJSONSerialization JSONObjectWithData:responseObj options:kNilOptions error:nil]; CYXLog(@"请求成功，返回数据 : %@",dictData); success(dictData); &#125; //状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; &#125; failure:^(NSError *error) &#123; if (failure) &#123; failure(error); CYXLog(@"请求失败：%@",error); &#125; //状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; &#125;];&#125;/** * 数据模型基类(带HUD) */+ (void)postBaseHUDWithUrl:(NSString *)url param:(id)param resultClass:(Class)resultClass success:(void (^)(id result))success warn:(void (^)(NSString *warnMsg))warn failure:(void (^)(NSError *error))failure tokenInvalid:(void (^)())tokenInvalid&#123; [SVProgressHUD showWithStatus:@""]; [self postBaseWithUrl:url param:param resultClass:resultClass success:^(id responseObj) &#123; [SVProgressHUD dismiss]; //隐藏loading success(responseObj); &#125; warn:^(NSString *warnMsg) &#123; [SVProgressHUD dismiss]; warn(warnMsg); &#125; failure:^(NSError *fail) &#123; [SVProgressHUD dismiss]; failure(fail); &#125; tokenInvalid:^&#123; [SVProgressHUD dismiss]; tokenInvalid(); &#125;];&#125;@end 到这里，轻量级的封装介绍已经全部介绍完了，更多的功能封装有待读者自己去研究了。既然封装好了，下面我们来介绍一下如何使用，其实非常简单。 使用介绍 1.把上述两个类的.h .m 文化拖到您项目中，最好新建一个文件夹。 2.在需要发送请求的Controller中#import &quot;CYXBaseRequest.h&quot; 3.发送请求方法中的代码如下： （使用CYXBaseRequest）： 12345678910111213141516171819202122232425#pragma mark - 请求数据方法- (void)loadData&#123; self.pn = 1; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @(self.pn); params[@"rn"] = @"10"; params[@"key"] = @"fcfdb87c50c1485e9e7fa9f839c4b1a8"; [CYXBaseRequest postResultWithUrl:CYXRequestURL param:params resultClass:[CYXMenu class] success:^(id result) &#123; CYXLog(@"请求成功，返回数据 : %@",result); self.menus = result; self.pn ++; // 刷新数据（若不刷新数据会显示不出） [self.tableView reloadData]; [self.tableView.mj_header endRefreshing]; &#125; warn:^(NSString *warnMsg) &#123; &#125; failure:^(NSError *error) &#123; CYXLog(@"请求失败 原因：%@",error); [self.tableView.mj_header endRefreshing]; &#125; tokenInvalid:^&#123; // 有登录操作的业务，这里返回登录状态 &#125;];&#125; 在这里对比一下不使用CYXBaseRequest的发送请求方法代码： 1234567891011121314151617181920212223242526#pragma mark - 请求数据方法- (void)loadData&#123; self.pn = 1; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @(self.pn); params[@"rn"] = @"10"; params[@"key"] = @"fcfdb87c50c1485e9e7fa9f839c4b1a8"; [self.manager.tasks makeObjectsPerformSelector:@selector(cancel)]; [self.manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObject:@"text/html"]]; [self.manager POST:CYXRequestURL parameters:params progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; CYXLog(@"请求成功，返回数据 : %@",responseObject); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu mj_objectArrayWithKeyValuesArray:responseObject[@"result"]]; weakSelf.pn ++; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData]; [weakSelf.tableView.mj_header endRefreshing]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; CYXLog(@"请求失败 原因：%@",error); [weakSelf.tableView.mj_header endRefreshing]; &#125;];&#125; 虽然从代码看似两种使用差别不太大（只是少了几行代码），但相比之下，前者确实降低了对AFN等框架的依赖，并省去了每次都手动转一下模型的烦恼，现在你只需要把resultClass传过去，返回的数据便是已经转化好的模型，并在CYXBaseRequest内打印出请求链接地址，返回数据等有用信息，方便调试，接口设计也类似AFN，使用简便。 TIPS:建议使用者可以在每个模块都建立Request文件（继承CYXBaseRequest），统一进行网络请求，这样更方便管理。 注： 本封装实践只对网络请求进行初步的简单封装，仅适用于中小型的项目，并不涉及缓存、校验等高级功能，如果有高级需求，建议研究下猿题库的YTKNetwork网络库。 附：源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS动画-Core Animation实现思路全解(OC)]]></title>
      <url>%2F2016%2F03%2F28%2FiOS%E5%8A%A8%E7%94%BB-Core%20Animation%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%85%A8%E8%A7%A3%3C%E9%99%84%E7%A4%BA%E4%BE%8BDemo%3E(OC)%2F</url>
      <content type="text"><![CDATA[附：(github)示例Demo地址，希望点个⭐️Star。thx☺ CABasicAnimation 基本动画 动画的本质就是修改图层的某些属性 核心动画,利用核心动画修改Layer某些属性 简介 基本动画是CAPropertyAnimation的子类 属性说明： fromValue：keyPath相应属性的初始值 toValue：keyPath相对应的结束值 动画过程说明： 随着动画的进行，在长度为duration的持续时间内，keyPath相应的属性值从fromValue渐渐变为toValue keyPath内容是CALayer的可动画Animatable属性 如果fillMode=kCAFillModeForwards同时removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。 以下是代码实现步骤： 1.创建基础核心动画CABasicAnimation *anim = [CABasicAnimation animation]; 2.描述修改Layer的某个属性(@”transform.rotation”…)anim.keyPath = @&quot;position”; 3.描述修改Layer属性的值 动画的起点（如果不设，以默认值为终点）anim.fromValue = @0 动画的终点anim.toValue = [NSValue valueWithCGPoint:CGPointMake(300, 400)]; 4.动画时长anim.duration = 1; 5.取消反弹 (1)在动画完成的时候不要给我把动画销毁anim.removedOnCompletion = NO; (2)动画永远保持最新的状态anim.fillMode = kCAFillModeForwards; 6.添加核心动画[_reaView.layer addAnimation:anim forKey:nil]; CAKeyframeAnimation——关键帧动画 简介 关键帧动画，也是CAPropertyAnimation的子类， 与CABasicAnimation的区别是： CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue），而CAKeyframeAnimation会使用一个NSArray保存这些数值 属性说明： values：上述的NSArray对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧 path：可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略 keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation 代码实现思路与步骤： 1.初始化帧动画 CAKeyframeAnimation *anim = [CAKeyframeAnimation animation]; 2.描述修改layer的属性, transform.rotation只能二维旋转 anim.keyPath = @&quot;transform.rotation&quot;; position anim.keyPath = @&quot;position&quot;; 3.修改Layer值 anim.values = @[@(angle2Radion(-5)),@(angle2Radion(5)),@(angle2Radion(-5))]; 创建路径UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:_imageView.center radius:100 startAngle:0 endAngle:M_PI * 2 clockwise:YES]; 4.设置动画的属性值 设置动画执行时间anim.duration = 2; 动画执行次数anim.repeatCount = MAXFLOAT; 5.添加动画到图层（Layer）[_imageView.layer addAnimation:anim forKey:nil]; CAAnimationGroup——动画组 简介 动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行 属性说明： animations：用来保存一组动画对象的NSArray默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间 CATransition——转场动画 简介: CATransition是CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点 UINavigationController就是通过`CATransition实现将控制器的视图推入(puch)屏幕的动画效果 动画属性: type：动画过渡类型 subtype：动画过渡方向 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) 代码实现思路与步骤： 注意点： 只要切换界面 都可以使用转场动画 谁切换界面 就添加到谁上 转场动画代码必须和界面切换的代码放在一起 1.写界面切换的代码（切换界面） 12345//设置在touchBegin方法中static int i = 2;NSString *imageName = [NSString stringWithFormat:@"%d",i];_imageView.image = [UIImage imageNamed:imageName];i++;` 2.初始化转场动画CATransition *anim = [CATransition animation]; 3.指定转场类型(其他样式见过度效果)anim.type = @&quot;pageCurl&quot;; 4.设置转场动画属性 (1)设置动画开始的进度anim.startProgress = 0.5; (2)设置动画结束的进度anim.endProgress = 0.8; (3)设置动画的时间anim.duration = 3; 5.添加转场动画到图层[_imageView.layer addAnimation:anim forKey:nil]; 转场动画过渡效果CADisplayLink定时器 CADisplayLink是一种以屏幕刷新频率触发的时钟机制，每秒钟执行大约60次左右，可以暂停CADisplayLink定时器 CADisplayLink是一个计时器，可以使绘图代码与视图的刷新频率保持同步，而NSTimer无法确保计时器实际被触发的准确时间，无法暂停 使用方法： 定义CADisplayLink并制定触发调用方法 将显示链接添加到主运行循环队列 代码实现步骤： 1.由于定时器只需要创建一次，因此定义为成员属性@property (nonatomic, weak) CADisplayLink *link; 2.使用懒加载link属性 123456789101112131415- (CADisplayLink *)link&#123; if (_link == nil) &#123; //(1)定义CADisplayLink并制定触发调用方法 CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timeChange)]; _link = link; //(2)加到主运行循环队列 [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; &#125; return _link;&#125; 3.实现触发调用方法 12345// 1秒调用60次 每次旋转45 / 60.0度- (void)timeChange&#123; _wheelView.transform = CGAffineTransformRotate(_wheelView.transform, (45 / 60.0) / 180.0 * M_PI);&#125; 4.开启定时器self.link.paused = NO;(YES为暂停) 附：(github)示例Demo地址，希望点个⭐️Star。thx☺]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS底层-KVC使用实践以及实现原理]]></title>
      <url>%2F2016%2F03%2F23%2FiOS%E5%BA%95%E5%B1%82-KVC%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[简介KVC（Key-value coding）键值编码，顾名思义。额，简单来说，是可以通过对象属性名称（Key）直接给属性值（value）编码（coding）“编码”可以理解为“赋值”。这样可以免去我们调用getter和setter方法，从而简化我们的代码，也可以用来修改系统控件内部属性（这个黑魔法且用且珍惜）。 1. 最简单的使用例子 假设有CYXModel类与CYXShopModel类，CYXModel里面有name、product属性，CYXShopModel里面有productName属性。 1234@interface CYXModel: NSObject @property (nonatomic, strong) NSString *name; @property (nonatomic, strong) CYXShopModel *product; @end 123@interface CYXShopModel: NSObject @property (nonatomic, strong) NSString * productName; @end 不使用KVC，我们这样访问CYXModel的属性 取值： 1234CYXModel *model = [[CYXModel alloc]init];NSString *name = model. name;CYXShopModel *shop = model. product;NSString *productName = shop. productName; 设值： 12345CYXModel *model = [[CYXModel alloc]init];model. name = @"CYX";CYXShopModel *shopModel = [[CYXShopModel alloc]init];shopModel. productName = @"NIKE";model. product = shopModel; 使用KVC，我们可以这样访问CYXModel的属性 取值： 123CYXModel *model = [[CYXModel alloc]init];NSString *name = [model valueForKey: @"name" ];NSString *productName = [model valueForKeyPath: @"product.productName" ]; 设值： 123CYXModel *model = [[CYXModel alloc]init];[model setValue:@"CYX" forKey:@"name"];[model setValue:@"NIKE" forKeyPath:@"product.productName"]; 注： 这个简单的例子，可能你看了觉得这并没什么卵用，下面我们来分析一下稍微有点卵用的例子吧。 2. KVC字典转模型的实现原理 假设dict字典中有name，icon的Key，CYXModel模型类中必须要有同名的name，icon属性与之相对应。 我们使用[CYXModel setValuesForKeysWithDictionary:dict];进行字典转模型。 setValuesForKeysWithDictionary:方法内部实现原理如下： (1) 遍历字典里面所有的key和值，name，icon。 1234567 // enumerateKeysAndObjectsUsingBlock:遍历字典中的所有keys和valus[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; // 利用KVC给模型中属性赋值,, // key:用来给哪个属性 // Value:给模型的值 [CYXModel setValue:obj forKey:key];&#125;]; (2) 分别给属性赋值 [CYXModel setValue:dict[@&quot;name&quot;] forKey:@&quot;name&quot;]; [CYXModel setValue:dict[@&quot;icon&quot;] forKey:@&quot;icon&quot;]; setValue:forKey:方法：给模型的属性赋值 赋值原理： （1）去模型中查找有没有setIcon方法,就直接调用这个set方法,给模型这个属性赋值[self setIcon:dict[@&quot;icon&quot;]]; （2）如果找不到set方法，接着就会去寻找有没有icon属性,如果有,就直接访问模型中icon = dict[@&quot;icon&quot;]; （3）如果找不到icon属性，接着又会去寻找_icon属性,如果有,直接_icon = dict[@&quot;icon&quot;]; （4）如果都找不到就会报错[&lt;Flag 0x7fb74bc7a2c0&gt; setValue:forUndefinedKey:] 扩展：读者可以去查查KVV（键值验证），进一步理解报错原因与容错方法。 注： 稍微有点卵用的看完，接下来说一个比较有卵用的用法，这个例子需要配合runtime来实现，有兴趣可以看看，runtime内容不少，这里就暂不介绍了，欢迎 关注，在下篇文字小结一下runtime。 3. 修改系统控件内部属性（runtime + KVC） 有时候，UI会闲着没事，会给你找点事情，例如，界面设计图是这样的： 这。。怎么感觉有点不同，这UIPageControl怎么跟我平常用的不一样？平常不都是这样的？？如下图 首先想到的肯定是，查看UIPageControl的头文件，如下： 12345678910111213141516NS_CLASS_AVAILABLE_IOS(2_0) @interface UIPageControl : UIControl @property(nonatomic) NSInteger numberOfPages; // default is 0@property(nonatomic) NSInteger currentPage; // default is 0. value pinned to 0..numberOfPages-1@property(nonatomic) BOOL hidesForSinglePage; // hide the the indicator if there is only one page. default is NO@property(nonatomic) BOOL defersCurrentPageDisplay; // if set, clicking to a new page won't update the currently displayed page until -updateCurrentPageDisplay is called. default is NO- (void)updateCurrentPageDisplay; // update page display to match the currentPage. ignored if defersCurrentPageDisplay is NO. setting the page value directly will update immediately- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; // returns minimum size required to display dots for given page count. can be used to size control if page count could change@property(nullable, nonatomic,strong) UIColor *pageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property(nullable, nonatomic,strong) UIColor *currentPageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@end 卧槽，就这么几个属性可以给我设的，不够用啊兄弟。能不能给我个可以赋值UIImage对象的属性？看来正常途径使用系统的控件是设不了了，剩下的我感觉只有两种方法（如有其它，欢迎指出），一种是自定义PageControl，这种方式看起来不简单，各位有兴趣可以去试试。另一种方式就是，通过runtime遍历出UIPageControl所有属性（包括私有成员属性，runtime确实很强大）。 使用runtime遍历UIPageControl结果（下篇文字再谈谈runtime，这里暂不解释）如下打印： 12345678910111213142016-03-23 01:09:26.161 TenMinDemo[6224:507269] UIPageControl -&gt; _lastUserInterfaceIdiom = q2016-03-23 01:09:26.161 TenMinDemo[6224:507269] UIPageControl -&gt; _indicators = @&quot;NSMutableArray&quot;2016-03-23 01:09:26.161 TenMinDemo[6224:507269] UIPageControl -&gt; _currentPage = q2016-03-23 01:09:26.161 TenMinDemo[6224:507269] UIPageControl -&gt; _displayedPage = q2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _pageControlFlags = &#123;?=&quot;hideForSinglePage&quot;b1&quot;defersCurrentPageDisplay&quot;b1&#125;2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _currentPageImage = @&quot;UIImage&quot; // 当前选中图片2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _pageImage = @&quot;UIImage&quot; // 默认图片2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _currentPageImages = @&quot;NSMutableArray&quot;2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _pageImages = @&quot;NSMutableArray&quot;2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _backgroundVisualEffectView = @&quot;UIVisualEffectView&quot;2016-03-23 01:09:26.162 TenMinDemo[6224:507269] UIPageControl -&gt; _currentPageIndicatorTintColor = @&quot;UIColor&quot;2016-03-23 01:09:26.163 TenMinDemo[6224:507269] UIPageControl -&gt; _pageIndicatorTintColor = @&quot;UIColor&quot;2016-03-23 01:09:26.163 TenMinDemo[6224:507269] UIPageControl -&gt; _legibilitySettings = @&quot;_UILegibilitySettings&quot;2016-03-23 01:09:26.163 TenMinDemo[6224:507269] UIPageControl -&gt; _numberOfPages = q 结果非常满意，果然找到我想要的图片设置属性。 然后通过KVC设置自定义图片，实现了效果，代码如下： 123UIPageControl *pageControl = [[UIPageControl alloc] init]; [pageControl setValue:[UIImage imageNamed:@&quot;home_slipt_nor&quot;] forKeyPath:@&quot;_pageImage&quot;];[pageControl setValue:[UIImage imageNamed:@&quot;home_slipt_pre&quot;] forKeyPath:@&quot;_currentPageImage&quot;]; 注：这里只是抛砖引玉的讲了个小例子，其他的神奇功能等待读者去发现啦。 提示： 在xib/Storyboard中，也可以使用KVC，下面是在xib中使用KVC把图片边框设置成圆角 KVC就先说到这里了，欢迎持续关注我的简书或Github。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔试-上机题（附个人见解）]]></title>
      <url>%2F2015%2F11%2F12%2FiOS%E7%AC%94%E8%AF%95-%E4%B8%8A%E6%9C%BA%E9%A2%98%EF%BC%88%E9%99%84%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3%EF%BC%89%2F</url>
      <content type="text"><![CDATA[机试题目如下 用命令行创建一个以CocoaPods管理的项目【Test-你的姓名拼音】，新建3个ViewController，完成以下题目 将下面的问题在一个UITabView里面列出所有问题，单击每一行进入一个新的页面，里面是问题和答案。 1.1 什么是VFL，请说出“H:[_aImageView(==50)]-10-[_aButton]”代表的意思？ 1.2 NSPersistentStoreCoordinator\NSManagedObjectContext和NSManagedObject三者什么关系 1.3 ARC下什么时候使用Strong，什么时候使用Weak，如何避免循环引用？ 1.4 将一个MRC的项目转换为ARC的项目，应该遵循什么规则？ 1.5 Objective-C如何对内存管理的，有哪些情况会导致崩溃，说说你的看法和解决方法？ 1.6 简述GCD是如何简化线程编程的？ 1.7 Extensions有哪些类型，每种类型可以完成的功能有哪些？ 1.8 如何衡量ViewController的规模？ 1.9 MVVM是什么，请简述MVVM的特点以及解决了哪些问题？ 2.请使用UIScrollerView控件实现图片的循环切换 3.请使用UICollectionView控件实现图片数据绑定，要求每行两列 参考思路1.新建以CocoaPods管理的项目 在命令行窗口输入以下命令 pod init pod install 等待Updating完毕以后文件夹的样式 打开test-cyx.xcworkspace文件 PS:下面只写思路，由于有点强迫症，想把题目做的完整一点，时间又不允许，就只把思路写写就好了 2.第一题（创建一个TableViewController） 1.我们假定问题和答案分别是字典的Key和Value,把十道题目分别存放到一个.plist文件中，使之能从.plist文件中读取 2.根据MVC思想，我们面向模型开发，而不是面向字典开发，因此，我们从plist文件中读出的字典数组需要转化为模型数组 （1）（M）我们需要定义模型test类，里面有两个属性： @property (nonatomic, copy) NSString *testName;题目 @property (nonatomic, copy) NSString *testContext;答案 （2）（V）创建一个用于展示问题和答案的PageViewController类，.h头文件里向外暴露了@property (nonatomic, strong) YXTest * text;属性 （3）（C）通过TableViewController类里面使用KVC把字典数据转为模型数据，再在以下方法把模型数据传递给PageViewController用于展示。 12345- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; PageViewController *page = [[PageViewController alloc]init]; page.text = self.text; [self.navigationController pushViewController:page animated:YES];&#125; 上面的Demo骨架已经搭完了，下面是解析一下问题的答案（当然，这些问题都可以从网上直接找到答案，这里只是简单说说我个人的理解，如有纰漏，欢迎指正） 什么是VFL，请说出“H:[_aImageView(==50)]-10-[_aButton]”代表的意思？ VFL:苹果为了简化手写Autolayout代码发明出来的，好像叫可视化格式语言（表示真的很久没用过啊！自从发现了Masonry），那行代码的意思应该是设置水平方向的约束。 手写Autolayout代码我一般使用第三方框架：Masonry。用Masonry写出来的代码的可读性非常好。 NSPersistentStoreCoordinator\\\\NSManagedObjectContext和NSManagedObject三者什么关系 CoreData里面的属性，NSPersistentStoreCoordinator：持久性数据协调器；NSManagedObjectModel：管理数据模型；NSManagedObjectContext：管理数据内容。三者的关系：CoreData根据NSManagedObjectModel对象确定如何将底层的持久化文件中的数据映射为NSManagedObject对象。 对于数据持久化的操作，我使用比较多的是通过FMDB框架操作SQLite，因为CoreData是基于OC封装了SQLite，性能并没有SQLite好。例如GCD性能比NSOperation好。 ARC下什么时候使用Strong，什么时候使用Weak，如何避免循环引用？ ARC下，是Xcode编译器自动判断是否有强指针引用着对象，从而自动帮我们在恰当的位置加上引用计数加一或减一的代码。使用Strong就表明这个OC对象是被使用强指针引用的。 因此，我们自己定义的需要使用的OC属性（UI控件除外）时，一般使用Strong；UI控件一般使用weak，因为在UI控件通常被父控件的subViews数组强引用着。 首先，循环引用的意思是两个对象互相强引用着(或者多个对象引用循环)，造成互相都无法释放，效果类似与‘死锁’。避免循环引用的方式是将其中一个对象设置为weak。我印象比较深的在使用block时造成的循环引用，例如使用AFN的时候123456789101112131415// 在AFN的block内使用，防止造成循环引用 __weak typeof(self) weakSelf = self; [[AFHTTPSessionManager manager] GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; NSLog(@"请求成功"); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@"result"]]; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData]; &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"请求失败 原因：%@",error); &#125;]; 将一个MRC的项目转换为ARC的项目，应该遵循什么规则？ (我也不太确定，猜的)规则难道是，需要转换为ARC文件的就转换，，不需要转换的就不转换？过滤掉无需转换的文件(不支持ARC的文件)。无需转换的文件应添加-fno-objc-arc标记 Objective-C如何对内存管理的，有哪些情况会导致崩溃，说说你的看法和解决方法？ (…上面已经问过ARC了，这题我猜是问iOS系统的内存管理原则了吧？) 当App收到三次内存警告还不做处理时，会造成闪退。 处理方法：在didReceiveMemoryWarning内释放不必要的资源。 简述GCD是如何简化线程编程的？ GCD相对于pthread/NSThread，通过自动管理线程的生命周期，从而简化了线程编程。 Extensions有哪些类型，每种类型可以完成的功能有哪些？ (那时候有几个忘了….)六种类型：Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard 完成的功能可以顾名思义 如何衡量ViewController的规模？ -（这个真的不太清楚。。求大神指导）是代码量？业务逻辑的复杂程度？还是ViewController做了过多数据加工的事情，造成ViewController的规模变大？ MVVM是什么，请简述MVVM的特点以及解决了哪些问题 M(Model)V(View)VM(ViewModel)，是一种View层的架构模式，衍生自MVC。 特点：把数据加工的任务从Controller中移到了ViewModel，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。 目标：为MVC中的Controller减负 请使用UIScrollerView控件实现图片的循环切换- CYXInfiniteScrollView.h文件 1234567#import &lt;UIKit/UIKit.h&gt;@interface CYXInfiniteScrollView : UIView@property (strong, nonatomic) NSArray *images;@property (weak, nonatomic, readonly) UIPageControl *pageControl;@property (assign, nonatomic, getter=isScrollDirectionPortrait) BOOL scrollDirectionPortrait;@end - CYXInfiniteScrollView.m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#import "CYXInfiniteScrollView.h"static int const ImageViewCount = 3;@interface CYXInfiniteScrollView() &lt;UIScrollViewDelegate&gt;@property (weak, nonatomic) UIScrollView *scrollView;@end@implementation CYXInfiniteScrollView- (instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; // 滚动视图 UIScrollView *scrollView = [[UIScrollView alloc] init]; scrollView.showsHorizontalScrollIndicator = NO; scrollView.showsVerticalScrollIndicator = NO; scrollView.pagingEnabled = YES; scrollView.bounces = NO; scrollView.delegate = self; [self addSubview:scrollView]; self.scrollView = scrollView; // 图片控件 for (int i = 0; i&lt;ImageViewCount; i++) &#123; UIImageView *imageView = [[UIImageView alloc] init]; [scrollView addSubview:imageView]; &#125; // 页码视图 UIPageControl *pageControl = [[UIPageControl alloc] init]; [self addSubview:pageControl]; _pageControl = pageControl; &#125; return self;&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; self.scrollView.frame = self.bounds; if (self.isScrollDirectionPortrait) &#123; self.scrollView.contentSize = CGSizeMake(0, ImageViewCount * self.bounds.size.height); &#125; else &#123; self.scrollView.contentSize = CGSizeMake(ImageViewCount * self.bounds.size.width, 0); &#125; for (int i = 0; i&lt;ImageViewCount; i++) &#123; UIImageView *imageView = self.scrollView.subviews[i]; if (self.isScrollDirectionPortrait) &#123; imageView.frame = CGRectMake(0, i * self.scrollView.frame.size.height, self.scrollView.frame.size.width, self.scrollView.frame.size.height); &#125; else &#123; imageView.frame = CGRectMake(i * self.scrollView.frame.size.width, 0, self.scrollView.frame.size.width, self.scrollView.frame.size.height); &#125; &#125; CGFloat pageW = 100; CGFloat pageH = 100; CGFloat pageX = self.scrollView.frame.size.width - pageW; CGFloat pageY = self.scrollView.frame.size.height - pageH; self.pageControl.frame = CGRectMake(pageX, pageY, pageW, pageH); [self updateContent];&#125;- (void)setImages:(NSArray *)images&#123; _images = images; // 设置页码 self.pageControl.numberOfPages = images.count; self.pageControl.currentPage = 0; // 设置内容 [self updateContent];&#125;#pragma mark - &lt;UIScrollViewDelegate&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // 找出最中间的那个图片控件 NSInteger page = 0; CGFloat minDistance = MAXFLOAT; for (int i = 0; i&lt;self.scrollView.subviews.count; i++) &#123; UIImageView *imageView = self.scrollView.subviews[i]; CGFloat distance = 0; if (self.isScrollDirectionPortrait) &#123; distance = ABS(imageView.frame.origin.y - scrollView.contentOffset.y); &#125; else &#123; distance = ABS(imageView.frame.origin.x - scrollView.contentOffset.x); &#125; if (distance &lt; minDistance) &#123; minDistance = distance; page = imageView.tag; &#125; &#125; self.pageControl.currentPage = page;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; [self updateContent];&#125;- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123; [self updateContent];&#125;#pragma mark - 内容更新- (void)updateContent&#123; // 设置图片 for (int i = 0; i&lt;self.scrollView.subviews.count; i++) &#123; UIImageView *imageView = self.scrollView.subviews[i]; NSInteger index = self.pageControl.currentPage; if (i == 0) &#123; index--; &#125; else if (i == 2) &#123; index++; &#125; if (index &lt; 0) &#123; index = self.pageControl.numberOfPages - 1; &#125; else if (index &gt;= self.pageControl.numberOfPages) &#123; index = 0; &#125; imageView.tag = index; imageView.image = self.images[index]; &#125; // 设置偏移量在中间 if (self.isScrollDirectionPortrait) &#123; self.scrollView.contentOffset = CGPointMake(0, self.scrollView.frame.size.height); &#125; else &#123; self.scrollView.contentOffset = CGPointMake(self.scrollView.frame.size.width, 0); &#125;&#125; 请使用UICollectionView控件实现图片数据绑定，要求每行两列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import "CYXCollectionViewController.h"@interface CYXCollectionViewController ()@end@implementation CYXCollectionViewControllerstatic NSString * const CYXCell = @"cell";- (instancetype)init&#123; // 流水布局 UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; layout.itemSize = CGSizeMake(150, 150); layout.minimumLineSpacing = 0; layout.minimumInteritemSpacing = 20; layout.sectionInset = UIEdgeInsetsMake(20, 0, 0, 0); return [self initWithCollectionViewLayout:layout];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.collectionView.backgroundColor = [UIColor whiteColor]; // 注册cell [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier: CYXCell];&#125;#pragma mark - &lt;UICollectionViewDataSource&gt;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 30;&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier: CYXCell forIndexPath:indexPath]; UIImageView *view = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@"xxx"]]; cell.backgroundView = view; return cell;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十分钟搭建主流框架_下拉/上拉刷新数据(OC)]]></title>
      <url>%2F2015%2F11%2F05%2F%E5%8D%81%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6_%E4%B8%8B%E6%8B%89%3A%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE(OC)%2F</url>
      <content type="text"><![CDATA[本节主题（网络部分-下拉/上拉刷新） 源码地址在文章末尾 达成效果 前言 经过十分钟搭建主流框架_简单的网络部分(OC)的介绍，相信你已经实现了基本的联网获取数据，但只是粗糙的获取了固定的数据，下面就让我们来实现下拉刷新和上拉加载更多吧。同样，我们先来做准备工作吧。 准备工作Github寻找优秀的第三方刷新框架 1.前人种树，后人乘凉。有优秀的第三方框架可以使用，当然是极好的，可以大大提高我们的开发效率，如有特殊需求只能自己手写就除外了 2.查阅第三方框架的README文件（读者自行阅读） 3.使用cocoapods集成到自己的项目中 刷新的基本实现思路下拉刷新 0.由于本文只关注功能的实现，先撇开原理，我们可以把刷新理解为从服务器加载最新的数据。 1.在viewDidLoad初始化下拉刷新控件，并绑定下拉刷新（请求网络数据）的方法,当触发下拉刷新，便会调用loadData方法。self.tableView.header = [MJRefreshNormalHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadData)]; 2.在loadData内实现请求网络数据（详见《十分钟搭建主流框架_简单的网络部分(OC)》）。 3.请求成功，停止刷新控件[weakSelf.tableView.header endRefreshing]; 4.请求失败，停止刷新控件[weakSelf.tableView.header endRefreshing]; 上拉加载更多 0.由于我们的实现是MVC模式，可以简单理解为：修改了模型的数据，View的界面展示也会随之变化。 1.定义‘页码’属性（用于加载下一页所要传递的参数）@property (nonatomic,assign) NSInteger pn; 2.初始化上拉刷新控件，并绑定上拉加载更多方法，当触发上拉加载事件，便会调用loadMoreData方法。self.tableView.footer = [MJRefreshAutoNormalFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)]; 3.在loadMoreData内实现加载更多数据的基本逻辑 （1）请求参数发生变化,加上params[@&quot;pn&quot;] = @(self.pn); （2）在请求成功的block内增加‘页码’weakSelf.pn ++; （3）在请求成功的block内使用新的模型数组接收数据NSArray *array = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@&quot;result&quot;]];并拼接到原数组的尾部 [weakSelf.menus addObjectsFromArray:array]; （4）刷新表格[weakSelf.tableView reloadData]; （5）停止刷新控件[weakSelf.tableView.footer endRefreshing]; 详细实现步骤 上代码(一)下拉 在setupTable内初始化头部刷新控件 123// 头部刷新控件self.tableView.header = [MJRefreshNormalHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadData)];[self.tableView.header beginRefreshing]; 实现loadData方法 123456789101112131415161718192021222324252627282930313233/** * 发送请求并获取数据方法 */- (void)loadData&#123; [self.manager.tasks makeObjectsPerformSelector:@selector(cancel)]; self.pn = 1; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @(self.pn); params[@"rn"] = @"10"; params[@"key"] = @"2ba215a3f83b4b898d0f6fdca4e16c7c"; // 在AFN的block内使用，防止造成循环引用 __weak typeof(self) weakSelf = self; [self.manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObject:@"text/html"]]; [self.manager GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; NSLog(@"请求成功"); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@"result"]]; weakSelf.pn ++; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData]; [weakSelf.tableView.header endRefreshing]; &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"请求失败 原因：%@",error); [weakSelf.tableView.header endRefreshing]; &#125;];&#125; (二)上拉 在setupTable内初始化上拉刷新控件 12// 尾部刷新控件self.tableView.footer = [MJRefreshAutoNormalFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)]; 实现loadMoreData方法 1234567891011121314151617181920212223242526272829303132/** * 加载更多数据 */- (void)loadMoreData&#123; [self.manager.tasks makeObjectsPerformSelector:@selector(cancel)]; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @(self.pn); params[@"rn"] = @"10"; params[@"key"] = @"2ba215a3f83b4b898d0f6fdca4e16c7c"; // 在AFN的block内使用，防止造成循环引用 __weak typeof(self) weakSelf = self; [self.manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObject:@"text/html"]]; [self.manager GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; // 利用MJExtension框架进行字典转模型 NSArray *array = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@"result"]]; [weakSelf.menus addObjectsFromArray:array]; weakSelf.pn ++; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData]; [weakSelf.tableView.footer endRefreshing]; &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"请求失败 原因：%@",error); [weakSelf.tableView.footer endRefreshing]; &#125;];&#125; 到这里已经简单实现了下拉与上拉刷新的功能，下次再讨论更多的其他功能吧 ^_^ 附：源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十分钟搭建主流框架_简单的网络部分(OC)]]></title>
      <url>%2F2015%2F10%2F16%2F%E5%8D%81%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6_%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86(OC)%2F</url>
      <content type="text"><![CDATA[本节主题（简单的网络部分） 源码地址在文章末尾 达成效果 注：本文API使用HaoService数据平台 前言 废话不说了，简单来说，移动网络很重要，下面让我们来实现一个简单的Demo：对网络数据的请求，并接收与展示吧。注意：是简单的！很简单的！ 准备工作1.文件目录结构示图（按照MVC分层） Controller: CYXOneViewController Model: CYXMenu View: CYXCell 2.使用cocoapods集成第三方框架 注：这里就直接使用cocoapods插件安装第三方框架了 这里要使用到的三方框架包括AFNetworking、MJExtension、SDWebImage 框架用途简介 AFNetworking：用于发送网络请求 MJExtension：用于把网络返回的JSON格式数据转换为模型属性 SDWebImage：用于下载网络图片 基本思路简述 1.在CYXOneViewController中使用AFNetworking发送GET请求,得到服务器返回的JSON格式的数据 2.使用MJExtension把JSON格式的数据转为模型CYXMenu对应的属性 3.在- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;方法内根据索引indexPath.row把每一行Cell的Model属性传递给自定义Cell(CYXCell) 4.在自定义Cell(CYXCell)内接收模型数据并初始化Cell的内部控件 5.不要忘记在AFN框架内的GET请求成功调用的block中刷新TableView的数据 详细实现 上代码 第一步：设计模型属性（CYXMenu.h），这里的属性名根据API文档设计，本Demo只是使用了其中几个简单的 123456789101112#import &lt;Foundation/Foundation.h&gt;@interface CYXMenu : NSObject/** 图片 */@property (copy, nonatomic) NSString * albums;/** 标题 */@property (nonatomic,copy) NSString *title;/** 材料 */@property (nonatomic,copy) NSString *ingredients;@end 第二步：自定义cell（这里使用Xib了） 2.1 拖控件到Xib中（见文件目录结构图） 2.2 在CYXCell.h中定义一个模型属性，用于供外界（CYXOneViewController）访问并传递模型进来。 12345678910#import &lt;UIKit/UIKit.h&gt;@class CYXMenu;@interface CYXCell : UITableViewCell/** 菜单模型 */@property (strong, nonatomic) CYXMenu * menu;@end 2.3 在CYXCell.m中实现menu属性的- (void)setMenu:(CYXMenu *)menu方法，将取到的menu模型值给cell自身的控件赋值由于这里需要通过URL下载网络图片，使用到了SDWebImage框架 1234567891011121314151617181920212223#import "CYXCell.h"#import "CYXMenu.h"#import &lt;UIImageView+WebCache.h&gt;@interface CYXCell ()@property (weak, nonatomic) IBOutlet UIImageView *albumsImageView;@property (weak, nonatomic) IBOutlet UILabel *titleLable;@property (weak, nonatomic) IBOutlet UILabel *ingredientsLabel;@end@implementation CYXCell- (void)setMenu:(CYXMenu *)menu&#123; _menu = menu; // 利用SDWebImage框架加载图片资源 [self.albumsImageView sd_setImageWithURL:[NSURL URLWithString:menu.albums]]; // 设置标题 self.titleLable.text = menu.title; // 设置材料数据 self.ingredientsLabel.text = menu.ingredients;&#125;@end 第三步，到这里我们需要在CYXOneViewController.m内实现 网络数据请求/JSON数据转模型/给自定义cell传递模型数据 的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#import "CYXOneViewController.h"#import "CYXCell.h"#import "CYXMenu.h"#import &lt;AFNetworking.h&gt;#import &lt;MJExtension.h&gt;@interface CYXOneViewController ()/** 存放数据模型的数组 */@property (strong, nonatomic) NSMutableArray * menus;@end@implementation CYXOneViewController#pragma mark - 全局常量// 发送请求URLstatic NSString * const CYXRequestURL = @"http://apis.haoservice.com/lifeservice/cook/query?";// 重用cell标识符static NSString * const CYXCellID = @"cell";#pragma mark - life cycle 生命周期方法- (void)viewDidLoad &#123; [super viewDidLoad]; self.tableView.rowHeight = 90; // 注册重用Cell [self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([CYXCell class]) bundle:nil] forCellReuseIdentifier:CYXCellID]; // 调用加载数据方法 [self loadData]; self.view.backgroundColor = [UIColor whiteColor];&#125;#pragma mark - private methods 私有方法/** * 发送请求并获取数据方法 */- (void)loadData&#123; // 请求参数（根据接口文档编写） NSMutableDictionary *params = [NSMutableDictionary dictionary]; params[@"menu"] = @"西红柿"; params[@"pn"] = @"1"; params[@"rn"] = @"20"; params[@"key"] = @"2ba215a3f83b4b898d0f6fdca4e16c7c"; // 在AFN的block内使用，防止造成循环引用 __weak typeof(self) weakSelf = self; [[AFHTTPSessionManager manager] GET:CYXRequestURL parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; NSLog(@"请求成功"); // 利用MJExtension框架进行字典转模型 weakSelf.menus = [CYXMenu objectArrayWithKeyValuesArray:responseObject[@"result"]]; // 刷新数据（若不刷新数据会显示不出） [weakSelf.tableView reloadData]; &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"请求失败 原因：%@",error); &#125;];&#125;#pragma mark - UITableviewDatasource 数据源方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.menus.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; CYXCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; cell.menu = self.menus[indexPath.row]; return cell;&#125;#pragma mark - UITableviewDelegate 代理方法- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 点击了第indexPath.row行Cell所做的操作&#125;@end 到这里只是简单实现了网络数据的请求，还有很多细节，例如下拉/上拉刷新，、cell的点击事件等等，有时间再讨论了。 附：源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五分钟搭建App设置页面_纯代码 + 模型思想(OC)]]></title>
      <url>%2F2015%2F09%2F12%2F%E4%BA%94%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BAApp%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2_%E7%BA%AF%E4%BB%A3%E7%A0%81%20%2B%20%E6%A8%A1%E5%9E%8B%E6%80%9D%E6%83%B3(OC)%2F</url>
      <content type="text"><![CDATA[本节主题（Storyboard/模型思想搭建设置页面） 源码地址在文章末尾 设置（Setting）页面的搭建(实现效果) 注：本文部分图标及效果图来自[IT江湖] https://github.com/itjhDev/itjh 开发方式（这里提供两种，个人感觉第二种重用性较高，推荐使用。但第一种较为简单，视开发需求选择） （1）纯代码 + StoryBoard混合 开发 （2）纯代码 + 模型 思想 设置页面的搭建 假设你已经搭建出了这个基本框架《十分钟搭建App主流框架》但这毕竟是个空壳，下面让我们把设置页面简单的搭建一下吧 注：本文仅仅提供简略的搭建方式与实现思路，更加详细的功能需要读者深入探究。 方式一（纯代码 + StoryBoard混合 开发） 第一步 新建StoryBoard文件，注意：命名与控制器相同 第二步 往StoryBoard一顿狂拖，你懂的 注意点：记得勾选第一个页面 is Initial View Controller 设置TableViewCell的样式 第三步（回到CYXTabBarController.m文件） 这里只需要改第四个控制器的代码,由于是从Storyboard中加载的控制器，与前三个不同。 12345678910111213141516171819202122232425/** * 添加所有子控制器 */- (void)setUpAllChildViewController&#123; // 1.添加第一个控制器 CYXOneViewController *oneVC = [[CYXOneViewController alloc]init]; [self setUpOneChildViewController:oneVC image:[UIImage imageNamed:@"tab_home_icon"] title:@"首页"]; // 2.添加第2个控制器 CYXTwoViewController *twoVC = [[CYXTwoViewController alloc]init]; [self setUpOneChildViewController:twoVC image:[UIImage imageNamed:@"js"] title:@"技术"]; // 3.添加第3个控制器 CYXThreeViewController *threeVC = [[CYXThreeViewController alloc]init]; [self setUpOneChildViewController:threeVC image:[UIImage imageNamed:@"qw"] title:@"博文"]; // 4.添加第4个控制器 // 4.1 初始化并从Storyboard中加载控制器 UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"CYXFourViewController" bundle:nil]; // 4.2 关联storyBoard与CYXFourViewController CYXFourViewController *fourVC = [storyBoard instantiateInitialViewController]; [self setUpOneChildViewController:fourVC image:[UIImage imageNamed:@"user"] title:@"设置"];&#125; 设置页面已经出来了 方式二（纯代码 + 模型 开发） 第一步 （新建模型文件） 第二步 （模型的设计） 组模型设计(CYXGroupitem.h)，分析每一组的所有元素：比如有头部标题，尾部标题，还有若干行Cell 12345678@interface CYXGroupItem : NSObject/** 头部标题 */@property (strong, nonatomic) NSString * headerTitle;/** 尾部标题 */@property (strong, nonatomic) NSString * footerTitle;/** 组中的行数组 */@property (strong, nonatomic) NSArray * items;@end 行模型的设计(CYXSettingItem.h)，分析每一行的所有元素：比如只有标题 1234@interface CYXSettingItem : NSObject@property (strong, nonatomic) NSString * title;/**&lt; 标题 */+ (instancetype)itemWithtitle:(NSString *)title;/**&lt; 设置标题值 类方法 */@end 类方法的实现(CYXSettingItem.m) 12345+ (instancetype)itemWithtitle:(NSString *)title&#123;CYXSettingItem *item = [[CYXSettingItem alloc]init];item.title = title;return item;&#125; 第三步 回到设置页面的控制器(CYXFourViewController.m) (1) 实现&lt; UITableViewDataSource &gt;协议的3个方法 (2) 给对应的模型设置值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#import "CYXFourViewController.h"#import "CYXSettingItem.h"#import "CYXGroupItem.h"@interface CYXFourViewController ()@property (strong, nonatomic) NSMutableArray * groups;/**&lt; 组数组 描述TableView有多少组 */@end@implementation CYXFourViewController/** groups 数据懒加载*/- (NSMutableArray *)groups&#123; if (!_groups) &#123; _groups = [NSMutableArray array]; &#125; return _groups;&#125;- (instancetype)init&#123; // 设置tableView的分组样式为Group样式 return [self initWithStyle:UITableViewStyleGrouped];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; //添加第1组模型 [self setGroup1]; //添加第2组模型 [self setGroup2]; //添加第3组模型 [self setGroup3];&#125;- (void)setGroup1&#123; // 创建组模型 CYXGroupItem *group = [[CYXGroupItem alloc]init]; // 创建行模型 CYXSettingItem *item = [CYXSettingItem itemWithtitle:@"我的账号"]; CYXSettingItem *item1 = [CYXSettingItem itemWithtitle:@"我的收藏"]; // 保存行模型数组 group.items = @[item,item1]; // 把组模型保存到groups数组 [self.groups addObject:group];&#125;- (void)setGroup2&#123; CYXGroupItem *group = [[CYXGroupItem alloc]init]; CYXSettingItem *item = [CYXSettingItem itemWithtitle:@"我去好评"]; CYXSettingItem *item1 = [CYXSettingItem itemWithtitle:@"我去吐槽"]; group.items = @[item,item1]; [self.groups addObject:group];&#125;- (void)setGroup3&#123; CYXGroupItem *group = [[CYXGroupItem alloc]init]; CYXSettingItem *item = [CYXSettingItem itemWithtitle:@"关注我们"]; CYXSettingItem *item1 = [CYXSettingItem itemWithtitle:@"关于我们"]; group.items = @[item,item1]; [self.groups addObject:group];&#125;#pragma mark - TableView的数据源代理方法实现/** * 返回有多少组的代理方法 */- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return self.groups.count;&#125;/** * 返回每组有多少行的代理方法 */- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; CYXGroupItem *group = self.groups[section]; return group.items.count;&#125;/** * 返回每一行Cell的代理方法 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 1 初始化Cell // 1.1 设置Cell的重用标识 static NSString *ID = @"cell"; // 1.2 去缓存池中取Cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; // 1.3 若取不到便创建一个带重用标识的Cell if (cell == nil) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; &#125; // 设置Cell右边的小箭头 cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator; // 2 设置数据 // 2.1 取出组模型 CYXGroupItem *group = self.groups[indexPath.section]; // 2.2 根据组模型取出行（Cell）模型 CYXSettingItem *item = group.items[indexPath.row]; // 2.3 根据行模型的数据赋值 cell.textLabel.text = item.title; return cell;&#125;@end 实现效果 如果你希望使用方式二实现点击Cell的跳转，需要实现下面的方法，并在里面调用navigationController的pushViewController方法跳转到你自定义的控制器。 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath; 看到这里，如果你是个iOS初学者，应该觉得方式2的实现过于繁琐，但方式2却是个一劳永逸的方式。换句话说，如果你用方式2封装了一个完整的设置页面的框架，在下一个项目中，再有类似的设置页面，你便可以直接把这个框架拷贝过去，改少量的代码便可以完美兼容，肯定比你再重新拖Storyboard要便捷，因此本人是比较推崇这种方式的。 附：源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十分钟搭建App主流框架_纯代码搭建(OC)]]></title>
      <url>%2F2015%2F09%2F04%2F%E5%8D%81%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BAApp%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6_%E7%BA%AF%E4%BB%A3%E7%A0%81%E6%90%AD%E5%BB%BA(OC)%2F</url>
      <content type="text"><![CDATA[搭建主流框架界面 源码地址在文章末尾 达成效果 注：本文部分图标及效果图来自[IT江湖] https://github.com/itjhDev/itjh 导读 我们玩iPhone应用的时候，有没发现大部分的应用都是上图差不多的结构，下面的TabBar控制器可以切换子控制器，上面又有Navigation导航条 我们本文主要是讨论主体框架的搭建，数据暂时没有添加 分析做项目的基本流程 1.搭建项目主框架 （1）先搭建tabBarController（下面有一条） （2）再搭建NavigationController（上面有一条，并且每个子控制器的不一样） 2.思考开发方式 （1）storyboard搭建（界面很少的时候使用） （2）纯代码搭建（界面超过5个的时候使用，易于管理，商业项目中，一般都使用这种方式） 从0开始搭建主流框架（纯代码）1.准备工作 环境部署 2.初步搭建基本界面 第一步 设计目录（根据模块化+MVC思想，创建基本文件目录与文件） 模块化思想创建目录路径（一般先在真实路径下创建，再拖到项目中） 自定义TabBarController 第二步 上代码（在AppDelegate.m内设置窗口启动根控制器） 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 1.创建窗口 self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds]; // 2.设置窗口的根控制器 CYXTabBarController *tabBarVC = [[CYXTabBarController alloc]init]; self.window.rootViewController = tabBarVC; // 3.显示窗口 [self.window makeKeyAndVisible]; return YES;&#125; 第三步，在CYXTabBarController.m内创建并添加子控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.添加第一个控制器 // 1.1 初始化 CYXOneViewController *oneVC = [[CYXOneViewController alloc]init]; // 1.2 把oneVC添加为UINavigationController的根控制器 UINavigationController *nav1 = [[UINavigationController alloc]initWithRootViewController:oneVC]; // 设置tabBar的标题 nav1.title = @"首页"; [nav1.navigationBar setBackgroundImage:[UIImage imageNamed:@"commentary_num_bg"] forBarMetrics:UIBarMetricsDefault]; // 设置tabBar的图标 nav1.tabBarItem.image = [UIImage imageNamed:@"tab_home_icon"]; // 设置navigationBar的标题 oneVC.navigationItem.title = @"首页"; // 设置背景色（这些操作可以交给每个单独子控制器去做） oneVC.view.backgroundColor = [UIColor whiteColor]; // 1.3 把UINavigationController交给UITabBarController管理 [self addChildViewController:nav1]; // 2.添加第2个控制器 CYXTwoViewController *twoVC = [[CYXTwoViewController alloc]init]; UINavigationController *nav2 = [[UINavigationController alloc]initWithRootViewController:twoVC]; nav2.title = @"技术"; nav2.tabBarItem.image = [UIImage imageNamed:@"js"]; twoVC.navigationItem.title = @"技术"; twoVC.view.backgroundColor = [UIColor blueColor]; [self addChildViewController:nav2]; // 3.添加第3个控制器 CYXThreeViewController *threeVC = [[CYXThreeViewController alloc]init]; UINavigationController *nav3 = [[UINavigationController alloc]initWithRootViewController:threeVC]; nav3.title = @"博文"; nav3.tabBarItem.image = [UIImage imageNamed:@"qw"]; threeVC.navigationItem.title = @"博文"; threeVC.view.backgroundColor = [UIColor yellowColor]; [self addChildViewController:nav3]; // 4.添加第4个控制器 CYXFourViewController *fourVC = [[CYXFourViewController alloc]init]; UINavigationController *nav4 = [[UINavigationController alloc]initWithRootViewController:fourVC]; nav4.title = @"我的江湖"; nav4.tabBarItem.image = [UIImage imageNamed:@"user"]; fourVC.navigationItem.title = @"我的江湖"; fourVC.view.backgroundColor = [UIColor grayColor]; [self addChildViewController:nav4];&#125; 进行到这里，我们已经把框架搭起来了，是不是很简单？效果如图： 但你可能会忍不住吐槽了，这些全是冗余的垃圾代码，没有可读性，下面就来抽取一下代码吧 第四步，抽取重复代码 由于上文的所有代码都写在viewDidLoad里面且重复代码过多，造成代码冗余，可扩展性不高的问题，下面让我们来对代码进行初步优化。 这里提取两个方法，一个是添加所有子控制器的方法，另一个是添加每一个子控制器的方法 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)viewDidLoad &#123; [super viewDidLoad]; [self setUpAllChildViewController];&#125;/** * 添加所有子控制器方法 */- (void)setUpAllChildViewController&#123; // 1.添加第一个控制器 CYXOneViewController *oneVC = [[CYXOneViewController alloc]init]; [self setUpOneChildViewController:oneVC image:[UIImage imageNamed:@"tab_home_icon"] title:@"首页"]; // 2.添加第2个控制器 CYXTwoViewController *twoVC = [[CYXTwoViewController alloc]init]; [self setUpOneChildViewController:twoVC image:[UIImage imageNamed:@"js"] title:@"技术"]; // 3.添加第3个控制器 CYXThreeViewController *threeVC = [[CYXThreeViewController alloc]init]; [self setUpOneChildViewController:threeVC image:[UIImage imageNamed:@"qw"] title:@"博文"]; // 4.添加第4个控制器 CYXFourViewController *fourVC = [[CYXFourViewController alloc]init]; [self setUpOneChildViewController:fourVC image:[UIImage imageNamed:@"user"] title:@"我的江湖"];&#125;/** * 添加一个子控制器的方法 */- (void)setUpOneChildViewController:(UIViewController *)viewController image:(UIImage *)image title:(NSString *)title&#123; UINavigationController *navC = [[UINavigationController alloc]initWithRootViewController:viewController]; navC.title = title; navC.tabBarItem.image = image; [navC.navigationBar setBackgroundImage:[UIImage imageNamed:@"commentary_num_bg"] forBarMetrics:UIBarMetricsDefault]; viewController.navigationItem.title = title; [self addChildViewController:navC];&#125; 附：源码github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-UIImagePickerController使用小结]]></title>
      <url>%2F2015%2F03%2F10%2FiOS%E7%AC%94%E8%AE%B0-UIImagePickerController%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[弹出UIImagePickerController（照片选择器） 如何进入系统的相册UIImagePickerController？ 1.创建一个照片选择控制器UIImagePickerController *imagePickerVc = [[UIImagePickerController alloc] init]; 2.设置数据源（弹出的是否直接是照片库）imagePickerVc.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; 3.设置代理（UIImagePickerControllerDelegate）imagePickerVc.delegate = self; 4.把图片库Modal出来[self presentViewController:imagePickerVc animated:YES completion:nil]; 如何监听并处理弹出来照片库的点击事件？ 1.遵守代理协议@interface ViewController ()&lt; UIImagePickerControllerDelegate&gt; 2.设置代理为selfimagePickerVc.delegate = self; 3.实现代理方法 12345678910- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info&#123; // 获取用户选择照片 UIImage *image = info[UIImagePickerControllerOriginalImage]; //把Modal出来的imagePickerController弹出 [self dismissViewControllerAnimated:YES completion:nil]; // 在此处理图片&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-一些零散的知识点(中)]]></title>
      <url>%2F2015%2F03%2F02%2FiOS%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9(%E4%B8%AD)%2F</url>
      <content type="text"><![CDATA[UITabBarController使用 UITabBarController的使用步骤 初始化UITabBarController 设置UIWindow的rootViewController为UITabBarController 根据具体情况，通过addChildViewController方法添加对应个数的子控制器 UITabBarController添加控制器的两种方式 1.添加单个子控制器 1- (void)addChildViewController:(UIViewController *)childController; 2.设置子控制器数组@property(nonatomic,copy) NSArray *viewControllers; UITabBarButton里面显示什么内容，由对应子控制器的tabBarItem属性决定 UITabBarItem有以下属性影响着UITabBarButton的内容 标题文字@property(nonatomic,copy) NSString *title; 图标@property(nonatomic,retain) UIImage *image; 选中时的图标@property(nonatomic,retain) UIImage *selectedImage; 提醒数字@property(nonatomic,copy) NSString *badgeValue; 示例代码： 手动在AppDelegate.m文件下手动创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 程序启动完成的时候就会调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 1.创建窗口 self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; // 2.设置窗口的根控制器 // 2.1 创建UITabBarController UITabBarController *tabBarVc = [[UITabBarController alloc] init]; // 2.2 设置tabBarVc为窗口根控制器 self.window.rootViewController = tabBarVc; // 3.添加子控制器 // 3.1创建子控制器 UIViewController *vc = [[UIViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; // 3.2设置UITabBarButton内容 // 标题 vc.tabBarItem.title = @"消息"; vc.tabBarItem.image = [UIImage imageNamed:@"tab_recent_nor"]; // 4.添加子控制器到tabBarVc [tabBarVc addChildViewController:vc];//======================================================== UIViewController *vc1 = [[UIViewController alloc] init]; vc1.view.backgroundColor = [UIColor greenColor]; vc1.tabBarItem.title = @"联系人"; vc1.tabBarItem.image = [UIImage imageNamed:@"tab_buddy_nor"]; vc1.tabBarItem.badgeValue = @"99+"; [tabBarVc addChildViewController:vc1]; UIViewController *vc2 = [[UIViewController alloc] init]; vc2.view.backgroundColor = [UIColor yellowColor]; [tabBarVc addChildViewController:vc2]; vc2.tabBarItem.badgeValue = @"10"; // 在iOS7之后才会默认渲染 // 默认UITabBar上的按钮如果被选中了,图片会被渲染成蓝色 // tabBarVC默认显示第0个控制器的view // 3.显示窗口 [self.window makeKeyAndVisible]; return YES;&#125; Modal的使用 除了push之外，还有另外一种控制器的切换方式，那就是Modal 任何控制器都能通过Modal的形式展示出来 Modal的默认效果：新控制器从屏幕的最底部往上钻，直到盖住之前的控制器为止 以Modal的形式展示控制器方法：- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion 关闭当初Modal出来的控制器方法：- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^)(void))completion; Modal原理解剖： 手写Modal 12345678910111213141516171819// 谁modal谁就强引用modal出来的控制器// oneVc被ViewController的presentedViewController强引用// 自己需要Modal出OneViewController的view// 1.把OneViewController的view添加到窗口上,移除之前窗口上的viewUIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;[keyWindow addSubview:oneVc.view];// 2.慢慢往上钻的动画// 先设置形变 oneVc.view.transform = CGAffineTransformMakeTranslation(0, keyWindow.bounds.size.height);[UIView animateWithDuration:0.5 animations:^&#123; // 还原形变 oneVc.view.transform = CGAffineTransformIdentity;&#125; completion:^(BOOL finished) &#123; [self.view removeFromSuperview];&#125;]; Modal与push的区别： 事件处理 iOS中的事件可以分为3大类型 1.触摸事件（重点掌握） 2.加速器事件 3.远程控制事件 响应者对象（UIResponder） 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象” UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件 UIResponder内部提供了以下方法来处理事件 1.触摸事件 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 2.加速计事件 - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 3.远程控制事件 - (void)remoteControlReceivedWithEvent:(UIEvent *)event; UIView的触摸事件处理 UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件 一根或者多根手指开始触摸view，系统会自动调用view的下面方法- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event提示：touches中存放的都是UITouch对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-导航控制器(Nav)的10条经验]]></title>
      <url>%2F2015%2F02%2F27%2FiOS%E7%AC%94%E8%AE%B0-%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8(Nav)%E7%9A%8410%E6%9D%A1%E7%BB%8F%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[1.导航控制器永远显示的是栈顶控制器的view 2.导航控制器中做界面之间的跳转必须取到导航控制器 3.调用pop方法并不会马上销毁当前控制器 4.popToViewController使用注意点：传入进去的控制器必须是导航控制器栈里面的控制器 5.导航条的内容由栈顶控制器决定,一个导航控制器只有一个导航条,因此只能由一个控制器决定,谁先显示在最外面,谁就是栈顶控制器. 6.在iOS7之后,默认会把导航条上的按钮的图片渲染成蓝色. 7.导航条上的子控件位置不需要我们管理,只需要管理尺寸 8.UINavigationItem:是一个模型,决定导航条的内容(左边内容,中间,右边内容) 9.UIBarButtonItem:是一个模型,决定导航条上按钮的内容 10.以后只要看到item,通常都是苹果提供的模型,只要改模型就能修改苹果的某些控件.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-数据存储科普篇]]></title>
      <url>%2F2015%2F02%2F21%2FiOS%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%A7%91%E6%99%AE%E7%AF%87%2F</url>
      <content type="text"><![CDATA[数据存储将数据保存到手机里面，保存到应用沙盒（app安装到手机上的文件夹）常见方式有以下几种：1.XML属性列表（plist）归档2.Preference(偏好设置)3.NSKeyedArchiver归档(NSCoding)4.SQLite35.Core Data 应用沙盒 每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录)，与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒 应用沙盒结构分析（文件夹分析）： Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录 tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录 Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据 Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录 应用沙盒目录的常见获取方式 沙盒根目录： NSString * home = NSHomeDirectory(); Documents:(两种方式) 1.利用沙盒根目录拼接“Documents”字符串(不建议使用) 123// 不建议采用，因为新版本的操作系统可能会修改目录名NSString *home = NSHomeDirectory();NSString *documents = [home stringByAppendingPathComponent:@"Documents"]; 2.利用NSSearchPathForDirectoriesInDomains函数 12345// NSUserDomainMask 代表从用户文件夹下找// YES 代表展开路径中的波浪字符“~”NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, NO);// 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素NSString *documents = [array objectAtIndex:0]; tmp: NSString *tmp = NSTemporaryDirectory(); Library/Caches：(跟Documents类似的2种方法) 1.利用沙盒根目录拼接”Caches”字符串 2.利用NSSearchPathForDirectoriesInDomains函数(将函数的第2个参数改为：NSCachesDirectory即可) Library/Preference： 通过NSUserDefaults类存取该目录下的设置信息 1.plist存储（属性列表） 属性列表是一种XML格式的文件，拓展名为plist 如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中 存数据 Plist存储，就是把某些对象写成plist文件，主要描述数组，字典 plist文件一般用来存储数组和字典 plist存储是苹果特有的，只有苹果才能生成plist plist存储不能存储自定义对象 具体用法： 1.定义一个字典NSDictionary *dict = @{@&quot;age&quot;:@&quot;18&quot;,@&quot;name&quot;:@&quot;xmg&quot;}; 2.搜索文件夹路径 Caches文件夹 在某个范围内容搜索文件夹的路径 directory:获取哪个文件夹 domainMask:在哪个范围下获取 NSUserDomainMask:在用户的范围内搜索 expandTilde是否展开全路径,YES:展开 123//NSArray *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);NSString *cachePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask, YES)[0]; 3.拼接文件全路径 1NSString *filePath = [cachePath stringByAppendingPathComponent:@"dict.plist"];` 4.写入文件 12// File:文件全路径 =&gt; 所有文件夹路径 + 文件路径[dict writeToFile:filePath atomically:YES]; 读数据 具体使用： 1.获取Caches文件夹路径 1NSString *cachePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0]; 2.拼接文件全路径 1NSString *filePath = [cachePath stringByAppendingPathComponent:@"dict.plist"]; 3.读取文件数据（存的时候用什么对象存，读取的时候也用什么对象读取） 1NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:filePath]; 2.Preference(偏好设置) 很多iOS应用都支持偏好设置，比如保存用户名、密码、字体大小等设置，iOS提供了一套标准的解决方案来为应用加入偏好设置功能 每个应用都有个NSUserDefaults实例，通过它来存取偏好设置 比如，保存用户名、字体大小、是否自动登录 存数据12345678// 偏好设置NSUserDefaults// 底层就是封装了一个字典,利用字典的方式生成plist// 好处:不需要关心文件名,快速进行键值对存储// name cyx[[NSUserDefaults standardUserDefaults] setObject:@"cyx" forKey:@"name"];// age 22[[NSUserDefaults standardUserDefaults] setInteger:22 forKey:@"age"];[[NSUserDefaults standardUserDefaults] setBool:YES forKey:@"isOn"]; 注意：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法强制写入 读数据12 NSString *name = [[NSUserDefaults standardUserDefaults] objectForKey:@"name"];BOOL ison = [[NSUserDefaults standardUserDefaults] boolForKey:@"isOn"]; 3.NSKeyedArchiver归档（NSCoding）写数据12345678910111213141516// 归档:自定义对象一般使用归档,为什么自定义对象需要归档,plist存储不能存储自定义对象Person *person = [[Person alloc] init];person.age = 22;person.name = @"cyx";// tempNSString *tempPath = NSTemporaryDirectory();// 拼接文件名NSString *filePath = [tempPath stringByAppendingPathComponent:@"person.data"];// 归档[NSKeyedArchiver archiveRootObject:person toFile:filePath];// -[Person encodeWithCoder:] 读数据123456789101112 // 什么对象存,读取出来就是什么对象 // temp NSString *tempPath = NSTemporaryDirectory(); // 拼接文件名 NSString *filePath = [tempPath stringByAppendingPathComponent:@"person.data"]; // 解挡Person *p = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath]; // -[Person initWithCoder:] NSLog(@"%@ %d",p.name,p.age);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-定位(LBS)小结]]></title>
      <url>%2F2015%2F02%2F10%2FiOS%E7%AC%94%E8%AE%B0-%E5%AE%9A%E4%BD%8D(LBS)%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[iOS8.0之前的定位前台定位 导入CoreLocation框架和对应的主头文件#import &lt;CoreLocation/CoreLocation.h&gt; 创建CLLcationManager对象,并设置代理_locationM = [[CLLocationManager alloc] init];_locationM.delegate = self; 调用CLLcationManager对象的startUpdatingLocation方法进行更新用户位置[_locationM startUpdatingLocation]; 实现代理方法,接收位置参数-(void)locationManager:(nonnull CLLocationManager *)manager didUpdateLocations:(nonnull NSArray&lt;CLLocation *&gt; *)locations 后台定位 在前台定位基础上,勾选后台模式update locations(如下图) iOS8.0+ 至 iOS9.0之间的定位前台定位 导入CoreLocation框架和对应的主头文件#import &lt;CoreLocation/CoreLocation.h&gt; 创建CLLcationManager对象,并设置代理 请求前台定位授权,并配置KEY123456_locationM = [[CLLocationManager alloc] init];_locationM.delegate = self;if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0) &#123;[_locationM requestWhenInUseAuthorization];&#125; 调用CLLcationManager对象的startUpdatingLocation方法进行更新用户位置[_locationM startUpdatingLocation]; 实现代理方法,接收位置参数 1-(void)locationManager:(nonnull CLLocationManager *)manager didUpdateLocations:(nonnull NSArray&lt;CLLocation *&gt; *)locations 后台定位 方案一:在APP处于前台定位授权场景下,勾选后台运行模式update locations (如下图)添加后台运行模式注意:如果APP处于后台,则会出现蓝条 方案二:请求前后台定位授权,并配置KEY[_locationM requestAlwaysAuthorization]; 各种授权状态讲解 123456789101112131415161718192021222324252627282930313233343536373839404142switch (status) &#123; // 用户还未决定 case kCLAuthorizationStatusNotDetermined: &#123; NSLog(@"用户还未决定"); break; &#125; // 问受限 case kCLAuthorizationStatusRestricted: &#123; NSLog(@"访问受限"); break; &#125; // 定位关闭时和对此APP授权为never时调用 case kCLAuthorizationStatusDenied: &#123; // 定位是否可用（是否支持定位或者定位是否开启） if([CLLocationManager locationServicesEnabled]) &#123; NSLog(@"定位开启，但被拒"); &#125;else &#123; NSLog(@"定位关闭，不可用"); &#125; break; &#125; // 获取前后台定位授权 case kCLAuthorizationStatusAuthorizedAlways:// case kCLAuthorizationStatusAuthorized: // 失效，不建议使用 &#123; NSLog(@"获取前后台定位授权"); break; &#125; // 获得前台定位授权 case kCLAuthorizationStatusAuthorizedWhenInUse: &#123; NSLog(@"获得前台定位授权"); break; &#125; default: break; &#125; iOS9.0 定位补充前台定位 1.导入CoreLocation框架和对应的主头文件#import &lt;CoreLocation/CoreLocation.h&gt; 2.创建CLLcationManager对象,并设置代理 请求前台定位授权,并配置KEY 123456789101112131415161718192021222324252627282930 _locationM = [[CLLocationManager alloc] init]; _locationM.delegate = self; if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0) &#123; [_locationM requestWhenInUseAuthorization]; &#125;``` - 3.调用CLLcationManager对象的startUpdatingLocation方法进行更新用户位置`[_locationM startUpdatingLocation];` - 4.实现代理方法,接收位置参数`-(void)locationManager:(nonnull CLLocationManager *)manager didUpdateLocations:(nonnull NSArray&lt;CLLocation *&gt; *)locations` #### 后台定位- 方案一:在APP处于前台定位授权场景下,勾选后台运行模式update locations (如下图) 并且,调用以下方法,设置允许后台定位```objcif ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0) &#123; _locationM.allowsBackgroundLocationUpdates = YES;&#125;``` 添加后台运行模式注意:如果APP处于后台,则会出现蓝条- 方案二:请求前后台定位授权,并配置KEY`[_locationM requestAlwaysAuthorization];` ## 补充 // 作用：按照定位精确度从低到高进行排序，逐个进行定位。如果获取到的位置不是精确度最高的那个，也会在定位超时后，通过代理告诉外界// 注意：一个要实现代理的定位失败方法； 二：不能与startUpdatingLocation同时使用[_locationM requestLocation];CLLocation对象详解 //coordinate （当前位置所在的经纬度） //altitude （海拔） //speed （当前速度） //-distanceFromLocation: （获取两个位置之间的直线物理距离）指南针1234- 导入CoreLocation框架和对应的主头文件`#import &lt;CoreLocation/CoreLocation.h&gt; ` - 创建CLLcationManager对象,并设置代理 _locationM = [[CLLocationManager alloc] init];_locationM.delegate = self;1234- 调用`CLLcationManager`对象的`startUpdatingHeading`方法进行更新设备朝向`[_locationM startUpdatingHeading];` - 实现代理方法,获取方向参数,根据方向参数旋转图片 -(void)locationManager:(nonnull CLLocationManager )manager didUpdateHeading:(nonnull CLHeading )newHeading { // 获取当前设备朝向(磁北方向) CGFloat angle = newHeading.magneticHeading; // 转换成为弧度 CGFloat radian = angle / 180.0 * M_PI; // 反向旋转指南针 [UIView animateWithDuration:0.5 animations:^{ self.compassView.transform = CGAffineTransformMakeRotation(-radian); }]; } 12345678*注意*: 获取用户的设备朝向,不需要用户进行定位授权## 区域监听- 导入CoreLocation框架和对应的主头文件`#import &lt;CoreLocation/CoreLocation.h&gt;` - 创建CLLcationManager对象,并设置代理,请求授权(iOS8.0之后才需要) 请求前后台定位授权,并配置KEY _locationM = [[CLLocationManager alloc] init];_locationM.delegate = self;if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0){ [_locationM requestAlwaysAuthorization];}12- 调用CLLcationManager对象的startMonitoringForRegion:方法进行监听指定区域 // 创建区域中心CLLocationCoordinate2D center = CLLocationCoordinate2DMake(29.12345, 131.23456);// 创建区域（指定区域中心，和区域半径） CLCircularRegion *region = [[CLCircularRegion alloc] initWithCenter:center radius:1000 identifier:@”广州”];// 开始监听指定区域[self.locationM startMonitoringForRegion:region];12 - 实现代理方法,获取区域进入或者离开状态 // 进去监听区域后调用（调用一次）-(void)locationManager:(nonnull CLLocationManager )manager didEnterRegion:(nonnull CLRegion )region{ NSLog(@”进入区域—%@”, region.identifier); [manager stopMonitoringForRegion:region];}// 离开监听区域后调用（调用一次）-(void)locationManager:(nonnull CLLocationManager )manager didExitRegion:(nonnull CLRegion )region{ NSLog(@”离开区域—%@”, region.identifier);}1234567891011## (反)地理编码- 导入CoreLocation框架和对应的主头文件`#import &lt;CoreLocation/CoreLocation.h&gt;` - 创建CLGeocoder对象`_geoC = [[CLGeocoder alloc] init];` ## 地理编码- 方案1: // 地理编码方案一：直接根据地址进行地理编码（返回结果可能有多个，因为一个地点有重名） [self.geoC geocodeAddressString:@”盛达商务园” completionHandler:^(NSArray __nullable placemarks, NSError __nullable error) { // 包含区，街道等信息的地标对象 CLPlacemark placemark = [placemarks firstObject]; // 城市名称 // NSString city = placemark.locality; // 街道名称 // NSString street = placemark.thoroughfare; // 全称 NSString name = placemark.name; self.addressDetailTV.text = [NSString stringWithFormat:@”%@”, name]; self.latitudeTF.text = [NSString stringWithFormat:@”%f”, placemark.location.coordinate.latitude]; self.longtitudeTF.text = [NSString stringWithFormat:@”%f”, placemark.location.coordinate.longitude]; }];1- 方案2: // 地理编码方案二：根据地址和指定区域两个条件进行地理编码（更加精确）[self.geoC geocodeAddressString:@”广州” inRegion:nil completionHandler:^(NSArray __nullable placemarks, NSError __nullable error) { // 包含区，街道等信息的地标对象 CLPlacemark *placemark = [placemarks firstObject]; self.addressDetailTV.text = placemark.description; self.latitudeTF.text = [NSString stringWithFormat:@”%f”, placemark.location.coordinate.latitude]; self.longtitudeTF.text = [NSString stringWithFormat:@”%f”, placemark.location.coordinate.longitude];}];12## 反地理编码 // 创建CLLocation对象CLLocation location = [[CLLocation alloc] initWithLatitude:23.132931 longitude:113.375924;// 根据CLLocation对象进行反地理编码[self.geoC reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark &gt; __nullable placemarks, NSError __nullable error) { // 包含区，街道等信息的地标对象 CLPlacemark placemark = [placemarks firstObject]; // 城市名称 // NSString city = placemark.locality; // 街道名称 // NSString street = placemark.thoroughfare; // 全称 NSString name = placemark.name; self.addressDetailTV.text = [NSString stringWithFormat:@”%@”, name];}];``` 定位的第三方框架 下载框架（locationManager框架） locationManager框架 下载地址 导入框架(直接拖入项目) 框架功能说明 可以使用block进行获取用户位置 可以设置超时时长 可以取消和强制终止定位 按照github中,该框架的readme参照使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-地图的基本使用]]></title>
      <url>%2F2015%2F02%2F10%2FiOS%E7%AC%94%E8%AE%B0-%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[导读： iOS开发中，很多时候系统提供的控件并不能很好的满足我们的需求，因此，自定义控件便成为搭建UI界面中必不可少的一部分。本篇博文以笔记的形式，总结了自定义控件的两种方式以及每种方式的实现步骤，虽简略却不简单，因此希望留给读者更多的思考空间。作为入门的编程学习者，独立思考能力和动手编程能力都是至关重要的。在此，希望大家学习愉快，共同进步。 自定义控件之xib方式 xib与storyboard 共同点： 都用来描述软件界面 都用Interface Builder工具来编辑 本质都是转换成代码去创建控件 不同点： Xib是轻量级的，用来描述局部的UI界面 Storyboard是重量级的，用来描述整个软件的多个界面，并且能展示多个界面之间的跳转关系 Xib的加载方式 方式一：通过mainBundel loadNibNamed:加载 1NSArray *views = [[NSBundle mainBundle] loadNibNamed:@"xib文件名" owner:nil options:nil]` 方式二：通过UINib nibWithNibName加载 12UINib *nib = [UINib nibWithNibName:@"xib文件名" bundle:nil];NSArray *views = [nib instantiateWithOwner:nil options:nil]; 通过xib创建自定义控件步骤： 新建一个继承UIView的类 新建一个xib文件（xib的文件名最好跟控件类名一样） 添加子控件、设置子控件属性 修改最外面那个控件的class为控件类名 将子控件进行连线 提供模型属性，重写模型的set方法 在set方法中给子控件设置数据 示例代码： 1234567891011- (void)viewDidLoad &#123; //1.通过mainbundel获取xib文件，返回组件数组 NSArray * viewArr = [[NSBundle mainBundle] loadNibNamed:@"CYXView" owner:nil options:nil]; //2.取出数组中需要的控件 CYXView * myView = (CYXView *)[viewArr lastObject]; //3.设置控件的Frame myView.frame = CGRectMake(100, 100, 10, 200); //4.控件添加到self.View中 [self.view addSubview:myView];&#125; 补充： initWithcoder 只要是从storyboard/xib中加载就会调用这个方法；这个方法一般是初始化的操作 awakeFromNib storyboard/xib中加载完毕的时候调用，想做一些在xib加载完毕的操作，就在这个方法中操作（建议在这个方法中写初始化代码） 自定义控件之纯代码方式 何为自定义控件？ 继承自系统自带的控件，写一个属于自己的控件 目的：封装控件内部的细节 为什么要封装？ 封装的话，下次直接将封装好的类，直接拿去使用封装以后，没有重复代码 自定义控件封装步骤： 创建一个自定义控件，建议直接继承自UIView，也可以继承自其他组件 封装的用途 以后需要封装一些框架给外界使用的时候对于项目扩展性大大提高 示例代码思路： 在新建的CYXShopView视图类(View)中代码思路如下 1.定义子控件。在init方法内只管控件内部的创建，但不管frame的初始化，因为外界调用的init方法不一定马上给frame赋值，所以第一次init是frame的值可能为nil 2.定义位置尺寸（Frame）。重写系统的-(void)layoutSubviews方法,这个方法方法专门用来布局子控件，一般在这里设置子控件的frame，当控件本身的尺寸发生改变的时候，系统会自动调用这个方法。重写此方法内一定要调用[super layoutSubviews] 3.设置数据。提供一个模型属性，重写模型属性的set方法，在set方法中取出模型属性，给对应的子控件赋值 在自定义控件内还可以添加其他更方便的初始化方法，可以参照apple官方的UIView等主要控件，还可以更高层次的封装，这个等以后再谈及。 1234567891011121314151617181920212223//重写-(instancetype)initWithFrame:(CGRect)frame方法//init方法内部会自动调用-(instancetype)initWithFrame:(CGRect)frame 方法，因此建议写这个方法，用于替代-(instancetype)init 方法-(instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super init]) &#123; //添加图片 UIImageView * iconView = [[UIImageView alloc]init]; iconView.backgroundColor = [UIColor grayColor]; [self addSubview:iconView]; //添加文字 UILabel * name = [[UILabel alloc]init]; name.backgroundColor = [UIColor greenColor]; name.font = [UIFont systemFontOfSize:15]; name.textAlignment = NSTextAlignmentCenter; [self addSubview:name]; &#125; return self;&#125; 1234567891011121314/** * 这个方法专门用来布局子控件，一般在这里设置子控件的frame * 当控件本身的尺寸发生改变的时候，系统会自动调用这个方 */-(void)layoutSubviews&#123; // 一定要调用super方法 [super layoutSubviews]; CGFloat shopW = self.frame.size.width; CGFloat shopH = self.frame.size.height; self.iconView.frame = CGRectMake(0, 0, shopW, shopW); self.name.frame = CGRectMake(0, shopW, shopW, shopH-shopW);&#125; 123456-(void)setShop:(CYXShop *)shop&#123; //赋值 _shop = shop; self.name.text = self.shop.name; self.iconView.image = [UIImage imageNamed:self.shop.icon];&#125; 补充： init和initWithFrame（一般在使用代码创建的时候调用 在调用init的时候，系统会默认调用一次initWithFrame；但在调用initWithFrame不会调用init；所以一般初始化自己的子控件一般都是放在initWithFrame 给封装View设置数据的几种方式 （1）直接将属性暴漏在.h文件中：不好，影响封装性，不应该将自己的子控件暴漏在头文件中 （2）提供一个初始化方法 （3）根据tag设置子控件数据 因为子控件较少，所以设置比较方便。 控制器做的的太多了 （4）提供一个设置模型的方法，将模型传递过去（直接传递一个模型对象给View自己设置值） （5）提供一个属性，直接使用点语法赋值（最终采取的方法）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-控制器传值总结(OC)]]></title>
      <url>%2F2015%2F02%2F05%2FiOS%E7%AC%94%E8%AE%B0-%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BC%A0%E5%80%BC%E6%80%BB%E7%BB%93(OC)%2F</url>
      <content type="text"><![CDATA[导读： iOS开发中，你肯定遇到过控制器之间的值或模型的传递，本文将从两种创建控制器的方式&amp;两种值传递的方向，分别介绍了如何进行控制器之间值传递的方法及步骤。因为博主知识水平有限，这只是实现值传递的其中几种方式，如果您有更好的建议，欢迎提出，大家一起讨论，共同进步。 纯代码方式 控制器之间传值 两个要点： 1.接收方一定要有属性去接收 2.传递方需要拿到接收方，进行直接赋值 顺传 上一级控制器传递给下一级控制器。 实现策略：直接拿到下一级控制器，拿到以后，做什么事情都行（对其属性赋值） 实现代码： 上一级控制器（传递方）：123456789101112131415161718#import "CYXContactViewController.h"#import "CYXContact.h"#import "CYXEditViewController.h"@implementation CYXContactViewController// 准备好segue线之后,跳转之前会调用// 做一些数据之间的传值- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; //获取目标控制器 CYXEditViewController *editVc = segue.destinationViewController; // 获取当前选中的角标 NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow]; // 获取选中的cell对应的模型 CYXContact *cont = self.contactArr[indexPath.row]; // 传递选中的cell对应的模型 editVc.contact = cont;&#125;@end 下一级控制器（接收方）：123456#import &lt;UIKit/UIKit.h&gt;@class CYXContact;@interface CYXEditViewController : UIViewController/** 用于存储联系人页传来的模型 */@property (strong, nonatomic) CYXContact * contact;@end 逆传 下一级控制器传递给上一级控制器。 实现策略：使用代理。上一级控制器作为下一级控制器的代理，监听下一级控制器的事情。 实现代码： 上一级控制器（接收方） 1234567891011121314**//1.遵守协议**@interface CYXContactViewController ()&lt;CYXAddViewControllerDelegate&gt;**//2.设置代理为self控制器**- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; CYXAddViewController *addVc = segue.destinationViewController; addVc.delegate = self;&#125;**//3.实现代理方法**- (void)addViewController:(CYXAddViewController *)addVc didAddContact:(CYXContact *)contact&#123; [self.contactArr addObject:contact]; [self.tableView reloadData];&#125; 下一级控制器（传递方） 12345678910111213141516171819202122232425262728293031323334353637.h 文件：#import &lt;UIKit/UIKit.h&gt;@class CYXContact,CYXAddViewController;@protocol CYXAddViewControllerDelegate&lt;NSObject&gt;@optional**//1.定义代理方法**#- (void)addViewController:(CYXAddViewController *)addVc didAddContact:(CYXContact *)contact;@end@interface CYXAddViewController : UIViewController**//2.声明代理属性**@property (nonatomic,weak) id&lt;CYXAddViewControllerDelegate&gt; delegate;@end.m 文件：@implementation CYXAddViewController// 逆传// (1)在跳转之前,在传递方把接收方先保存起来// (2)等需要真的给接收方传值的时候,直接拿到它传值// 点击添加按钮的时候调用- (IBAction)addContact:(id)sender &#123; // 把姓名和电话文本框的内容包装成模型 CYXContact *contact = [CYXContact contactWithName:_nameField.text phone:_phoneField.text];**// 3.调用代理方法，通知代理接收联系人模型** if ([_delegate respondsToSelector:@selector(addViewController:didAddContact:)]) &#123; [_delegate addViewController:self didAddContact:contact]; &#125; // 回到上一个控制器 [self.navigationController popViewControllerAnimated:YES];&#125; Storyboard方式 认识Segue 什么是Segue Storyboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue） Segue的属性 唯一标识：@property (nonatomic, readonly) NSString *identifier; 来源控制器：@property (nonatomic, readonly) id sourceViewController; 目标控制器：@property (nonatomic, readonly) id destinationViewController; Segue的类型（可分为两大类） 自动型：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转 按住Control键，直接从控件拖线到目标控制器 如果点击某个控件后，不需要做任何判断，一定要跳转到下一个界面，建议使用自动Segue； 手动型：需要通过写代码手动执行Segue，才能完成界面跳转 按住Control键，从来源控制器拖线到目标控制器 手动型的Segue需要设置一个标识（Identifier） 在恰当的时刻，使用perform方法执行对应的Segue，完成界面跳转 12[self performSegueWithIdentifier:@"login2contacts" sender:nil];// Segue必须由来源控制器来执行，也就是说，这个perform方法必须由来源控制器来调用 如果点击某个控件后，需要做一些判断，也就是说：满足一定条件后才跳转到下一个界面，建议使用“手动型Segue” performSegueWithIdentifier:sender:方法的完整执行过程： 1.根据identifier去storyboard中找到对应的Segue线，新建UIStoryboardSegue对象 - 设置Segue对象的sourceViewController（来源控制器） 新建并且设置Segue对象的destinationViewController（目标控制器） 2.调用sourceViewController（源控制器）的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象 123456789 // 准备好segue线之后,跳转之前会调用 // 做一些数据之间的传值 -(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // 执行跳转 CYXContactViewController *vc = segue.destinationViewController; // 传值 vc.accountStr = _accountField.text;&#125; 3.调用Segue对象的- (void)perform;方法开始执行界面跳转操作 如果segue的style是push 取得sourceViewController所在的UINavigationController 调用UINavigationController的push方法将destinationViewController压入栈中，完成跳转 如果segue的style是modal 调用sourceViewController的presentViewController方法将destinationViewController展示出来 模型的值发生改变时通知控制器（使用Notification通知）&lt;跨控制器传值也可采取这种方式&gt; 在上一个控制器修改了同一个模型数据 12345678910- (IBAction)saveBtnClick:(UIButton *)sender &#123; //修改模型数据 _contact.name = self.nameFiel.text; _contact.phonenum = self.phoneFiel.text; //发出通知 [[NSNotificationCenter defaultCenter]postNotificationName:@"contactChange" object:nil]; [self.navigationController popViewControllerAnimated:YES];&#125; 在下一个展示模型数据的控制器接收通知，刷新视图 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //监听模型更新通知 [[NSNotificationCenter defaultCenter]addObserverForName:@"contactChange" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) &#123; //此处处理监听的事件 //只要监听到通知就会调用 //这里是更新模型，刷新表格 [self.tableView reloadData]; &#125;];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-一些零散的知识点]]></title>
      <url>%2F2015%2F02%2F02%2FiOS%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[info.plist文件 1.Bundle name : app名称,项目通常使用英文,app名称显示中文 2.Bundle identifier : app标识符 上传AppStore和推送 3.Bundle versions string, short app版本号 PCH文件 pch作用: 1.存放一些公用的宏 2.存放一些公用的头文件 3.自定义Log 12345678910111213// 程序在调试阶段的时候才需要打印// ...表示宏里面的可变参数// __VA_ARGS__表示函数里面的可变参数#ifdef DEBUG // 表示当前调试阶段#define CYXLog(...) NSLog(__VA_ARGS__)#else // 发布阶段#define CYXLog(...)#endif pch原理:就是把pch文件中的所有内容拷贝到所有文件的头部 注意点: pch文件一定要注意做些判断,判断下当前是否是OC文件,如果是就 导入OC的代码 所有的OC文件都会定义__OBJC__这个宏,苹果官方定义 和C混编：注意点：判断单下是否是OC文件 12345#ifdef __OBJC__// 放OC#endif 123// 判断系统的版本号#define iOS8 ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0)#define iPhone5 ([UIScreen mainScreen].bounds.size.height == 568) UIApplication 常识 UIApplication对象是应用程序的象征 每一个应用都有自己的UIApplication对象，而且是单例 通过[UIApplication sharedApplication]可以获得这个单例对象 一个iOS程序启动后创建的第一个对象就是UIApplication对象 利用UIApplication对象，能进行一些应用级别的操作 1.应用程序图片的提醒数字 2.联网状态 3.设置状态栏 4.打开资源,电话,网页,发短信 何为单例 1.整个应用程序只有一份内存. 2.重写alloc方法,只分配一次. 3.提供share方法,获取单例对象. 4.使用静态全局变量保存单例对象. 示例代码（模仿系统UIApplication 写一个单例Person） 模仿系统单例UIApplication特征： 1.程序一启动的时候,苹果就会帮你创建UIApplication， 2.你如果调用alloc，系统马上抛异常 1234567891011121314151617181920212223242526272829303132#import "Person.h"// 1.程序一启动的时候就创建这个类的对象// 2.不允许外界通过alloc分配内存,只要一调用,马上抛异常@implementation Person// 人的实例static Person *_instance;// 程序运行的时候就会加载类+ (void)load&#123; _instance = [[self alloc] init];&#125;// exception 'NSInternalInconsistencyException', reason: 'There can only be one UIApplication instance.'+ (instancetype)alloc&#123; if (_instance) &#123; // 崩溃 // 创建异常对象 NSException *excption = [NSException exceptionWithName:@"NSInternalInconsistencyException" reason:@"There can only be one Person instance." userInfo:nil]; // 抛异常 [excption raise]; &#125; // super -&gt; [NSObject alloc] return [super alloc];&#125;+ (instancetype)sharedPerson&#123; return _instance;&#125;@end UIApplicationDelegate 常识 1.在app受到干扰时，会产生一些系统事件，这时UIApplication会通知它的delegate对象，让delegate代理来处理这些系统事件 2.delegate可处理的事件包括： 2.1应用程序的生命周期事件(如程序启动和关闭) 2.2系统事件(如来电) 2.3内存警告 123456789101112131415161718192021222324252627// 应用程序的生命周期// 应用程序启动完成的时候调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; return YES;&#125;// 当我们应用程序即将失去焦点的时候调用- (void)applicationWillResignActive:(UIApplication *)application &#123;&#125;// 当我们应用程序完全进入后台的时候调用- (void)applicationDidEnterBackground:(UIApplication *)application&#123;&#125;// 当我们应用程序即将进入前台的时候调用- (void)applicationWillEnterForeground:(UIApplication *)application &#123;// 当我们应用程序完全获取焦点的时候调用// 只有当一个应用程序完全获取到焦点,才能与用户交互.- (void)applicationDidBecomeActive:(UIApplication *)application &#123;&#125;// 当我们应用程序即将关闭的时候调用- (void)applicationWillTerminate:(UIApplication *)application &#123;&#125;@end 程序启动原理 一.首先找到程序入口,执行main函数 main -&gt; UIApplicationMain 二.UIApplicationMain底层做的事情 1.创建UIApplication对象 2.创建UIApplication的代理对象,而且给UIApplication对象代理属性赋值 3.开启主运行循环,作用接收事件,让程序一直运行 4.加载info.plist,判断下有木有指定main.storyboard,如果指定就会去加载 三.函数介绍: NSStringFromClass:根据一个类名生成一个类名字符串 NSClassFromString: 根据一个类名字符串生成一个类名 四.为什么使用NSStringFromClass NSStringFromClass:输入类名有提示,避免输入错误 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; UIWindow 什么时候创建 1.加载info.plist,判断有没有指定main.storyboard,指定了main.storyboard,就会去加载main.storyboard,执行main.storyboard的时候创建. main.storyboard步骤 2.1创建窗口 2.2加载控制器 2.3设置窗口的根控制器,显示窗口 手动创建窗口 1.什么时候创建? 1.1 在加载info.plist文件之后,程序启动才完成,启动完成之后,就要显示窗口,因此在程序启动完成的时候创建窗口. 1234567891011121314151617181920 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 窗口显示的注意点: // 1.一定要强引用 // 2.控件要想显示出来,必须要有尺寸 // 1.创建窗口 self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; // 2.创建根控制器,在设置窗口的根控制器 UIViewController *vc = [[UIViewController alloc] init]; // 设置窗口的根控制器,底层会自动把根控制器的view添加到窗口上,并且让控制器的view有旋转功能 self.window.rootViewController = vc; // 3.显示窗口 // makeKeyAndVisible:让窗口成为应用程序的主窗口,并且显示窗口 [self.window makeKeyAndVisible]; return YES;&#125; 窗口补充 1.应用程序中那些控件属于窗口,1.状态栏 2.键盘 2.窗口层级关系UIWindowLevelAlert &gt; UIWindowLevelStatusBar &gt; UIWindowLevelNormal设置窗口的层级,层级谁大就显示在最外面 3.UITextField显示键盘 注意点: 如果一个键盘想要弹出来,必须把textField添加到一个控件上. addSubView和rootViewController的区别 1&gt; 直接用addSubView,控制器会被释放,控制器就不能处理事件 2&gt;直接用addSubView,控制器的view不会自动旋转。 3&gt; 用rootViewController,控制器不会被释放,而且控制器的view会自动旋转 4&gt;旋转事件-&gt;UIApplication -&gt;Window-&gt;rootViewController -&gt;旋转控制器的view]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-UIScrollView]]></title>
      <url>%2F2015%2F01%2F23%2FiOS%E7%AC%94%E8%AE%B0-UIScrollView%2F</url>
      <content type="text"><![CDATA[前言：非常基础的学习笔记，挺久之前（大概两年前吧）刚开始学iOS时记录的，知识点是全的，拿出来回顾一下。 如何使用UIScrollView(使用步骤) 1.创建UIScrollView 2.给UIScrollView添加子控件 3.设置UIScrollView的滚动范围self.scrollView.contenSize = CGSizeMake(300,300); 4.默认情况下只要可以滚动，就有弹簧效果,bounces属性设置是否有回弹效果 5.设置滚动条的样式和控制滚动条的显示123self.scrollview.indecatorStyle = UIScrollViewIndeicatorStyleWhite;//白色样式self.scrollview.showHorizontalScrollIndicator = NO;//不显示水平方向的滚动条self.scrollview.shoeVericalScrollIndicator = NO;//垂直方向的滚动条 iOS开发屏幕坐标系 x轴：越往右边越大 Y轴：越往下边越大 UIScrollView常用属性 @property(nonatomic) CGPoint contentOffset; 这个属性用来表示UIScrollView滚动的位置（其实就是内容左上角与scrollView左上角的间距值） 作用: 用于设置内容的滚动偏移位 计算公式: 移动的距离 = “控件的左上角” - “内容的左上角” 最好先理解iOS的坐标系, 然后再理解公式 @property(nonatomic) CGSize contentSize; 这个属性用来表示UIScrollView内容的尺寸，滚动范围（能滚多远） @property(nonatomic) UIEdgeInsets contentInset; 作用: 在contentSize周围添加额外的滚动区域 应用场景: 避免UIScrollview中的内容被遮挡 bounces: 用于设置UIScrollview是否有回弹效果 alwaysBounceVertical/alwaysBounceHorizontal 如果UIScrollview已经设置contentSize, 那么YES和NO没有区别 只有UIScrollview没有设置contentSize才有效果 应用场景: 下拉刷新 indicatorStyle: 设置滚动条的样式 showsHorizontalScrollIndicator/showsVerticalScrollIndicator YES显示滚动条/ NO隐藏滚动条 注意理解区分: contentSize/contentOffset/contentInset/frame UIScrollView不能滚动的原因 1.没有设置contentSize 2.scrollEnabled = NO 3.userInteractionEnabled = NO userInteractionEnabled不是Disabled,他们两有本质的区别 Disabled代表控件不能使用, 状态是Disabled状态 userInteractionEnabled代表控件是否可以交互 UIScrollView使用注意点 在企业开发中，不用使用subviews来获取UIScrollView中的子控件 因为subviews中包含了UIScrollview中的滚动条, 而且滚动条的顺序是不确定的 何监听一个控件 首先需要查看该控件的头文件, 看它继承于哪个父类 如果继承于UIControl, 那么就可以通过addTarget来监听 如果不是继承于UIControl, 那么就必须通过代理(delegate)来监听 代理（UIScrollViewDelegate） 使用代理的步骤: 1.遵守代理协议 2.实现代理方法 3.将遵守了协议的对象设置为代理 代理的规律: 代理名称的规律: 协议名称以类名开头, 后面跟上Delegate 代理方法名称的规律 方法名称以类名去掉前缀开头, 并且谁触发这个方法就将谁传递出去 代理类型一般是id 代理属性一般是weak, 主要是为了避免循环引用 因为一般情况下, 控件的代理都是控制器, 而控件又是添加到控制器的view中 代理的应用场景 1.当A对象想监听B对象的变化时, 就可以使用代理, 让A成为B的代理 2.当B对象想通知A对象的时候, 就可以使用代理, 让A成为B的代理 如何监听UIScrollview停止滚动 scrollViewDidEndDragging 只要用户松手就会调用 停止拖拽并不代表停止滚动, 也就是说UIScrollView滚动是有惯性的 scrollViewDidEndDecelerating 只要UIScrollview有惯性就会调用,如果没有惯性就不会调用 想要监听UIScrollview停止滚动必须同时实现这两个方法 1234567891011121314- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@"%s = %d", __func__, decelerate); // 1.判断是否有惯性, 如果没有惯性手动调用scrollViewDidEndDecelerating告知已经完全停止滚动 if (decelerate == NO) &#123; [self scrollViewDidEndDecelerating:scrollView]; &#125;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"停止滚动"); self.iv.alpha = 1.0;&#125; UIScrollview缩放 步骤: 1.成为UIScrollview的代理, 通过代理方法告诉UIScrollview要缩放哪一个子控件 2.设置子控件最大和最小的缩放比例 常用方法 viewForZoomingInScrollView : 返回需要缩放的子控件 scrollViewDidZoom: 只要子控件被缩放了就会调用(调用频率非常高) scrollViewDidEndZooming: 缩放完毕时掉用 如何保证被缩放的子控件永远居中 只要子控件的contentSize小于UIScrollview的宽高时才需要缩放 第一种方法 123456789101112// 1.判断contentSize的宽高, 是否小于UIScrollView的frame的size if (scrollView.contentSize.width &lt; scrollView.bounds.size.width) &#123; self.iv1.center = CGPointMake(scrollView.bounds.size.width * 0.5, scrollView.bounds.size.height * 0.5); &#125; if (scrollView.contentSize.height &lt; scrollView.bounds.size.height) &#123; self.iv1.center = CGPointMake(scrollView.bounds.size.width * 0.5, scrollView.bounds.size.height * 0.5); &#125; 第二种方法 123456789101112131415161718// 1.判断contentSize的宽高, 是否小于UIScrollView的frame的size if (scrollView.contentSize.width &lt; scrollView.bounds.size.width) &#123; // 计算X的值 CGFloat x = (scrollView.contentSize.width * 0.5) + ((scrollView.bounds.size.width - scrollView.contentSize.width) * 0.5); // 重新设置center self.iv1.center = CGPointMake(x, self.iv1.center.y); &#125; if (scrollView.contentSize.height &lt; scrollView.bounds.size.height) &#123; // 计算Y的值 CGFloat y = (scrollView.contentSize.height * 0.5) + ((scrollView.bounds.size.height - scrollView.contentSize.height) * 0.5); // 重新设置center self.iv1.center = CGPointMake(self.iv1.center.x, y); &#125; 第三种方法 123CGFloat x = scrollView.contentSize.width &lt; scrollView.bounds.size.width ? (scrollView.bounds.size.width - scrollView.contentSize.width) * 0.5 : 0.0; CGFloat y = scrollView.contentSize.height &lt; scrollView.bounds.size.height ? (scrollView.bounds.size.height - scrollView.contentSize.height) * 0.5 : 0.0; self.iv1.center = CGPointMake(scrollView.contentSize.width * 0.5 + x, scrollView.contentSize.height * 0.5 + y); 图片轮播器Demo 如何分页 : pagingEnabled = YES 分页的原理: 是根据UIScrollview的宽度或者高度来分页 UIPageControl numberOfPages : 设置总页码 currentPage: 设置当前页码 pageIndicatorTintColor: 设置其它页码的颜色 currentPageIndicatorTintColor : 设置当前页码的颜色 自定义页码 利用KVC给UIPageControl设置页码图片 12[pageControl setValue:[UIImage imageNamed:@"current"] forKeyPath:@"_currentPageImage"];[pageControl setValue:[UIImage imageNamed:@"other"] forKeyPath:@"_pageImage"]; 监听UIPageControl的点击 由于UIPageControl继承于UIControl, 所以通过addTargt来监听 1[pageControl addTarget:self action:@selector(nextPage) forControlEvents:UIControlEventValueChanged]; 切换页码 滚动完毕之后再切换 12345678910111213141516171819- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; // 判断是否有惯性, 如果没有就手动调用scrollViewDidEndDecelerating if (NO == decelerate) &#123; [self scrollViewDidEndDecelerating:scrollView]; &#125;&#125;// 只有有惯性才会调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; // 1.动态计算当前的页码 // 页码 = UIScrollView的偏移位 / UIScrollView的宽度 int page = scrollView.contentOffset.x / scrollView.bounds.size.width; NSLog(@"page = %d", page); // 2.设置当前的页码 self.pageControl.currentPage = page;&#125; 实时切换 1234567891011// 只要滚动就会调用- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // 1.动态计算当前的页码 // 页码 = UIScrollView的偏移位 / UIScrollView的宽度 CGFloat page = scrollView.contentOffset.x / scrollView.bounds.size.width; NSLog(@"page = %f", page + 0.5); // 2.设置当前的页码 self.pageControl.currentPage = (int)(page + 0.5);&#125; NSTimer 作用: 可以让系统每隔一段时间执行指定对象的指定方法 注意: 间隔时间是不准确的 只要通过scheduledTimerWithTimeInterval创建出来的Timer,就会被RUNLOOP强引用, 所以如果通过属性保存使用weak 只要调用了NSTimer的invalidate方法, 那么定时器就不能使用了, 想要使用必须重新创建 如何主线程正在处理其它操作, 那么NSTimer不会执行 默认NSTimer是NSDefaultRunLoopMode模式 要想在主线程处理其它操作的时候也处理NSTimer, 那么必须把NSTiemr在RunLoop中的模式改为NSRunLoopCommonModes 如何暂停和启动定时器 123// 暂停定时器// 设置timer的开始时间为 遥远的未来 4001年[self.timer setFireDate:[NSDate distantFuture]]; 1234// 开启定时器// 设置定时器的开始时间为过去的某一个时间, 也就意味着立刻开始// 设置定时器从当前时间之后两秒才开始执行[self.timer setFireDate:[NSDate dateWithTimeIntervalSinceNow:2.0]]; 封装思想 只要发现控制器知道得太多,就要考虑重构代码 只要发现一个效果很多地方都需要使用, 就要考虑封装]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-RunLoop、NSURLConnection（OC）]]></title>
      <url>%2F2015%2F01%2F23%2FiOS%E7%AC%94%E8%AE%B0-RunLoop%E3%80%81NSURLConnection%EF%BC%88OC%EF%BC%89%2F</url>
      <content type="text"><![CDATA[附：我的github地址 什么是RunLoop 运行循环 一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop得手动启动（调用run方法） RunLoop只能选择一个Mode启动，如果当前Mode中没有任何Source(Sources0、Sources1)、Timer，那么就直接退出RunLoop RunLoop作用 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件、Selector事件） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息…… 模拟RunLoop内部实现 其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer） 12345678910111213void message(int num)&#123; printf("执行第%i个任务", num);&#125;int main(int argc, const char * argv[]) &#123; do &#123; printf("有事做吗? 没事做我休眠了"); int number; scanf("%i", &amp;number); message(number); &#125; while (1); return 0;&#125; 获得RunLoop对象 RunLoop对象 NSRunLoop CFRunLoopRef Foundation 12[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation 12CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 RunLoop结构 CFRunLoopRef对应RunLoop对象 CFRunLoopModeRef代表RunLoop的运行模式, 系统默认注册了5个Mode NSDefaultRunLoopMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 NSRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode CFRunLoopTimerRef是基于时间的触发器 CFRunLoopTimerRef基本上说的就是NSTimer，它受RunLoop的Mode影响 CFRunLoopSourceRef是事件源（输入源） CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 123456789101112131415161718192021222324252627282930313233343536373839404142// 1.创建Observer // 第一个参数:用于分配该observer对象的内存 // 第二个参数:用以设置该observer所要关注的的事件 // 第三个参数:用于标识该observer是在第一次进入run loop时执行, 还是每次进入run loop处理时均执行 // 第四个参数:用于设置该observer的优先级 // 第五个参数: observer监听到事件时的回调block CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch(activity) &#123; case kCFRunLoopEntry: NSLog(@"即将进入loop"); break; case kCFRunLoopBeforeTimers: NSLog(@"即将处理timers"); break; case kCFRunLoopBeforeSources: NSLog(@"即将处理sources"); break; case kCFRunLoopBeforeWaiting: NSLog(@"即将进入休眠"); break; case kCFRunLoopAfterWaiting: NSLog(@"刚从休眠中唤醒"); break; case kCFRunLoopExit: NSLog(@"即将退出loop"); break; default: break; &#125; &#125;); // 2.添加监听 /* 第一个参数: 给哪个RunLoop添加监听 第二个参数: 需要添加的Observer对象 第三个参数: 在哪种模式下监听 */ CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopDefaultMode); // 3,释放observer CFRelease(observer); RunLoopRunLoop处理逻辑（略） RunLoopRunLoop应用 NSTimer 只能在指定的model下运行12NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; ImageView显示 只能在指定的model下设置图片 PerformSelector 只能在指定的model下调用1[self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:[UIImage imageNamed:@"lnj"] waitUntilDone:YES modes:@[NSDefaultRunLoopMode]]; 常驻线程 必须调用run才会执行死循环 NSRunLoop的model中必须有source/timer,死循环才不会退出123NSRunLoop *runloop = [NSRunLoop currentRunLoop];[runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runloop run] 自动释放池 12345activities = 0x1 = 11: 即将进入RunLoop : 创建一个自动释放池activities = 0xa0 = 160 = 128 + 3232:即将休眠 : 释放上一次的自动释放池, 创建一个新的自动释放池128:即将退出RunLoop : 释放自动释放池 NSURLRequest 用于保存请求地址/请求头/请求体 默认情况下NSURLRequest会自动给我们设置好请求头 request默认情况下就是GET请求 同步请求 如果是调用NSURLConnection的同步方法, 会阻塞当前线程 1234567891011121314151617// 1.创建一个URLNSURL *url = [NSURL URLWithString:@"http://129.168.1.1:31812/login2?username=cyx&amp;pwd=123&amp;type=JSON"];// 2.根据URL创建NSURLRequest对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.利用NSURLConnection对象发送请求/* 第一个参数: 需要请求的对象 第二个参数: 服务返回给我们的响应头信息 第三个参数: 错误信息 返回值: 服务器返回给我们的响应体 */NSHTTPURLResponse *response = nil; // 真实类型NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:nil];NSLog(@"%@", [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);NSLog(@"response = %@", response.allHeaderFields); 异步请求 12345678910111213141516// 1.创建一个URLNSURL *url = [NSURL URLWithString:@"http://129.168.1.1:31812/login2?username=cyx&amp;pwd=123&amp;type=JSON"];// 2.根据URL创建NSURLRequest对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.利用NSURLConnection对象发送请求/* 第一个参数: 需要请求的对象 第二个参数: 回调block的队列, 决定了block在哪个线程中执行 第三个参数: 回调block */// 注意点: 如果是调用NSURLConnection的同步方法, 会阻塞当前线程[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; NSLog(@"%@", [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);&#125;]; POST方法 12345678910111213141516// 1.创建一个URLNSURL *url = [NSURL URLWithString:@"http://129.168.1.1:31812/login"];// 2.根据URL创建NSURLRequest对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 2.1设置请求方式// 注意: POST一定要大写request.HTTPMethod = @"POST";// 2.2设置请求体// 注意: 如果是给POST请求传递参数: 那么不需要写?号request.HTTPBody = [@"username=cyx&amp;pwd=123&amp;type=JSON" dataUsingEncoding:NSUTF8StringEncoding];// 3.利用NSURLConnection对象发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; NSLog(@"%@", [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);&#125;]; 请求服务器响应 12345678910111213141516171819// 1.创建URLNSURL *url = [NSURL URLWithString:@"http://xxx.jpg"];// 2.根据URL创建NSURLRequestNSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.利用NSURLConnection发送请求/*// 只要调用alloc/initWithRequest, 系统会自动发送请求[[NSURLConnection alloc] initWithRequest:request delegate:self];*//*// startImmediately: 如果传递YES, 系统会自动发送请求; 如果传递NO, 系统不会自动发送请求NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];[conn start];*/[NSURLConnection connectionWithRequest:request delegate:self]; + 代理方法 123456789101112131415161718192021222324252627282930313233#pragma mark - NSURLConnectionDataDelegate/* 只要接收到服务器的响应就会调用 response:响应头 */- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; NSLog(@"%s", __func__);&#125;/* 接收到服务器返回的数据时调用(该方法可能调用一次或多次) data: 服务器返回的数据(当前这一次传递给我们的, 并不是总数) */- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; NSLog(@"%s", __func__);&#125;/* 接收结束时调用 */- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; NSLog(@"%s", __func__);&#125;/* 请求错误时调用(请求超时) */- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; NSLog(@"%s", __func__);&#125; 中文问题 12345// 1.创建URL NSString *urlStr = @"http://129.168.1.1:31812/login2?username=cyx&amp;pwd=123&amp;type=JSON"; NSLog(@"转换前:%@", urlStr); // 2.对URL进行转码 urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 附：我的github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-多线程相关(pthread 、NSThread 、GCD、NSOperation)]]></title>
      <url>%2F2015%2F01%2F22%2FiOS%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3(pthread%20%E3%80%81NSThread%20%E3%80%81GCD%E3%80%81NSOperation)%2F</url>
      <content type="text"><![CDATA[进程 进程是指在系统中正在运行的一个应用程序 线程 1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程） 1个线程中任务的执行是串行的(执行完上一个才能执行下一个) 多线程 1个进程中可以开启多条线程，多条线程可以并行（同时）执行不同的任务 线程可以并行, 但是每个线程中的任务还是串行 多线程原理 多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换） 多线程优缺点 优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 缺点 线程越多，CPU在调度线程上的开销就越大 如果开启大量的线程，会降低程序的性能 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 pthread 类型: C语言中类型的结尾通常 _t/Ref，而且不需要使用 *123456789101112131415161718192021/*参数: 1. 线程代号的地址 2. 线程的属性 3. 调用函数的指针 - void *(*)(void *) - 返回值 (函数指针)(参数) - void * 和 OC 中的 id 是等价的 4. 传递给该函数的参数返回值: 如果是0，表示正确 如果是非0，表示错误码*/NSString *str = @"lnj"; pthread_t thid; int res = pthread_create(&amp;thid, NULL, &amp;demo, (__bridge void *)(str)); if (res == 0) &#123; NSLog(@"OK"); &#125; else &#123; NSLog(@"error %d", res); &#125; NSThread 一个NSThread对象就代表一条线程 创建线程的几种方式 alloc/init 123456789// 1.创建线程NJThread *thread = [[NJThread alloc] initWithTarget:self selector:@selector(demo:) object:@"lnj"];// 设置线程名称[thread setName:@"xmg"];// 设置线程的优先级// 优先级仅仅说明被CPU调用的可能性更大[thread setThreadPriority:1.0];// 2.启动线程[thread start]; detach/performSelector 优点：简单快捷 缺点：无法对线程进行更详细的设置 123456// 1.创建线程[NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@"lnj"];// 1.创建线程// 注意: Swift中不能使用, 苹果认为这个方法不安全 [self performSelectorInBackground:@selector(demo:) withObject:@"lnj"]; 多线程的安全隐患 被锁定的代码同一时刻只能有一个线程执行 1@synchronized(锁对象) &#123; // 需要锁定的代码 &#125; 互斥锁的优缺点优点：能有效防止因多线程抢夺资源造成的数据安全问题缺点：需要消耗大量的CPU资源 互斥锁注意点 锁定1份代码只用1把锁，用多把锁是无效的 锁定范围越大, 性能越差 原子和非原子属性 atomic：线程安全，需要消耗大量的资源 nonatomic：非线程安全，适合内存小的移动设备 自旋锁 &amp; 互斥锁 共同点都能够保证同一时间，只有一条线程执行锁定范围的代码 不同点 互斥锁：如果发现有其他线程正在执行锁定的代码，线程会进入”休眠”状态，等待其他线程执行完毕，打开锁之后，线程会被”唤醒” 自旋锁：如果发现有其他线程正在执行锁定的代码，线程会”一直等待”锁定代码执行完成！自旋锁更适合执行非常短的代码！ 线程间通信 子线程做耗时操作, 主线程更新数据 12345678[self performSelectorInBackground:@selector(download) withObject:nil]; /* waitUntilDone是否等待被调用方法执行完成，有可能也会等待调用方法的执行完成！ YES: 等待被调用线程执行完毕再执行后面的代码 NO : 不用等待被调用线程执行完毕就可以执行后面的代码 */[self performSelectorOnMainThread:@selector(showImage:) withObject:[UIImage imageWithData:data] waitUntilDone:YES]; GCD GCD中有2个核心概念 任务：执行什么操作 队列：用来存放任务 执行任务 同步方法: dispatch_sync 异步方法: dispatch_async 同步和异步的区别 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 队列 并发队列 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 注意点 同步和异步主要影响：能不能开启新的线程 同步：只是在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：允许多个任务并发（同时）执行 串行：一个任务执行完毕后，再执行下一个任务 各种任务队列搭配 同步 + 串行 同步 + 并发 异步 + 串行 异步 + 并发 异步 + 主队列 同步 + 主队列 GCD线程间通信 1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 执行耗时的异步操作... dispatch_async(dispatch_get_main_queue(), ^&#123; // 回到主线程，执行UI刷新操作 &#125;);&#125;); GCD其它用法 延时执行 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2秒后执行这里的代码...&#125;); 一次性代码 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(这里面默认是线程安全的)&#125;); 快速迭代 123dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index)&#123; // 执行10次代码，index顺序不确定&#125;); barrier 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行 不能是全局的并发队列 所有的任务都必须在一个队列中 1dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 队列组 12345678910dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 执行1个耗时的异步操作&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 执行1个耗时的异步操作&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步操作都执行完毕后，回到主线程...&#125;); NSOperation NSOperation的作用 配合使用NSOperation和NSOperationQueue也能实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动将NSOperationQueue中的NSOperation取出来 将取出的NSOperation封装的操作放到一条新线程中执行 NSOperation的子类 NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类 使用NSOperation子类的方式有3种1231.NSInvocationOperation2.NSBlockOperation3.自定义子类继承NSOperation，实现内部相应的方法 1.NSInvocationOperation 1.创建NSInvocationOperation对象 - (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 2.调用start方法开始执行操作- (void)start; 一旦执行操作，就会调用target的sel方法 注意 - 默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作 - 只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 2.NSBlockOperation 1.创建NSBlockOperation对象+ (id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作- (void)addExecutionBlock:(void (^)(void))block; 注意 - 只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 NSOperationQueue NSOperationQueue的作用 NSOperation可以调用start方法来执行任务，但默认是同步执行的 如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作 添加操作到NSOperationQueue中- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; 最大并发数 什么是并发数 同时执行的任务数 比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消、暂停、恢复 取消队列的所有操作 - (void)cancelAllOperations; 提示：也可以调用NSOperation的- (void)cancel方法取消单个操作 暂停和恢复队列- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; 操作依赖 NSOperation之间可以设置依赖来保证执行顺序 比如一定要让操作A执行完后，才能执行操作B，可以这么写[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 操作的监听 可以监听一个操作的执行完毕- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block; 自定义NSOperation 自定义NSOperation的步骤 重写- (void)main方法，在里面实现想执行的任务 重写- (void)main方法的注意点: 自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池） 经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 NSOperationQueue和GCD对比+ GCD * 并发: 自己创建, 全局 * 串行: 自己创建, 主队列 + NSOperationQueue * 主队列: mainQueue + 永远在主线程中执行 * 自己创建队列: alloc init + 会开启新的线程, 在子线程中执行 + 如何控制并行和串行 * maxConcurrentOperationCount = -1 ; 并行 * 默认就是并行 * maxConcurrentOperationCount = 1 ; 串行 * maxConcurrentOperationCount = 0 ; 不会执行 + 使用步骤: * 和GCD一样 * 1.创建操作(任务) * 2.将任务添加到队列中 + 快速添加任务的方法 12345// 只要利用队列调用addOperationWithBlock:方法, 系统内部会自动封装成一个NSBlockOperation \ 然后再添加到队列中[queue addOperationWithBlock:^&#123; NSLog(@"3 == %@", [NSThread currentThread]); &#125;]; 队列的暂停和恢复以及取消 暂停 self.queue.suspended = YES; 注意点:暂停其实是暂停下一个任务, 而不能暂停当前任务 恢复 self.queue.suspended = NO; 注意点: 恢复之后会继续执行队列中没有被执行的操作 取消 [self.queue cancelAllOperations]; 实现原理: 调用所有操作的cancel方法 注意点: 取消其实是取消下一个任务, 而不能取消当前任务 如果自定义操作中做了很多耗时操作, 苹果建议定期检查是否已经取消了 12345678910111213141516171819202122232425- (void)main&#123; // 耗时操作1 for (int i = 0; i &lt; 10000; i++) &#123; // 500 NSLog(@"%i ==== %@", i, [NSThread currentThread]); &#125; NSLog(@"++++++++++++++++++++++++++++++++++++++"); if (self.isCancelled) &#123; return; &#125; // 耗时操作2 for (int i = 0; i &lt; 10000; i++) &#123; // 500 NSLog(@"%i ==== %@", i, [NSThread currentThread]); &#125; if (self.isCancelled) &#123; return; &#125; NSLog(@"++++++++++++++++++++++++++++++++++++++"); // 好所操作3 for (int i = 0; i &lt; 10000; i++) &#123; // 500 NSLog(@"%i ==== %@", i, [NSThread currentThread]); &#125;&#125; 队列之间的依赖 在操作添加到队列之前, 利用操作调用addDependency, 就快要添加依赖 添加依赖之后, 只有所有依赖的任务都执行完毕, 才会执行当前任务 注意点: 不要相互依赖 特点: 跨队列依赖(GCD默认是不支持) 12345// 3.添加依赖 [op5 addDependency:op1]; [op5 addDependency:op2]; [op5 addDependency:op3]; [op5 addDependency:op4]; 操作的监听 只需要利用操作调用completionBlock即可 只要任务执行完毕, 就会回调completionBlock 线程间的通信 将任务添加到自己创建的队列中 再利用mainQueue回到主队列]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS笔记-自定义控件(OC)]]></title>
      <url>%2F2015%2F01%2F21%2FiOS%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6(OC)%2F</url>
      <content type="text"><![CDATA[导读： iOS开发中，很多时候系统提供的控件并不能很好的满足我们的需求，因此，自定义控件便成为搭建UI界面中必不可少的一部分。本篇博文以笔记的形式，总结了自定义控件的两种方式以及每种方式的实现步骤，虽简略却不简单，因此希望留给读者更多的思考空间。作为入门的编程学习者，独立思考能力和动手编程能力都是至关重要的。在此，希望大家学习愉快，共同进步。 自定义控件之xib方式 xib与storyboard 共同点： 都用来描述软件界面 都用Interface Builder工具来编辑 本质都是转换成代码去创建控件 不同点： Xib是轻量级的，用来描述局部的UI界面 Storyboard是重量级的，用来描述整个软件的多个界面，并且能展示多个界面之间的跳转关系 Xib的加载方式 方式一：通过mainBundel loadNibNamed:加载 1NSArray *views = [[NSBundle mainBundle] loadNibNamed:@"xib文件名" owner:nil options:nil]` 方式二：通过UINib nibWithNibName加载 12UINib *nib = [UINib nibWithNibName:@"xib文件名" bundle:nil];NSArray *views = [nib instantiateWithOwner:nil options:nil]; 通过xib创建自定义控件步骤： 新建一个继承UIView的类 新建一个xib文件（xib的文件名最好跟控件类名一样） 添加子控件、设置子控件属性 修改最外面那个控件的class为控件类名 将子控件进行连线 提供模型属性，重写模型的set方法 在set方法中给子控件设置数据 示例代码： 1234567891011- (void)viewDidLoad &#123; //1.通过mainbundel获取xib文件，返回组件数组 NSArray * viewArr = [[NSBundle mainBundle] loadNibNamed:@"CYXView" owner:nil options:nil]; //2.取出数组中需要的控件 CYXView * myView = (CYXView *)[viewArr lastObject]; //3.设置控件的Frame myView.frame = CGRectMake(100, 100, 10, 200); //4.控件添加到self.View中 [self.view addSubview:myView];&#125; 补充： initWithcoder 只要是从storyboard/xib中加载就会调用这个方法；这个方法一般是初始化的操作 awakeFromNib storyboard/xib中加载完毕的时候调用，想做一些在xib加载完毕的操作，就在这个方法中操作（建议在这个方法中写初始化代码） 自定义控件之纯代码方式 何为自定义控件？ 继承自系统自带的控件，写一个属于自己的控件 目的：封装控件内部的细节 为什么要封装？ 封装的话，下次直接将封装好的类，直接拿去使用封装以后，没有重复代码 自定义控件封装步骤： 创建一个自定义控件，建议直接继承自UIView，也可以继承自其他组件 封装的用途 以后需要封装一些框架给外界使用的时候对于项目扩展性大大提高 示例代码思路： 在新建的CYXShopView视图类(View)中代码思路如下 1.定义子控件。在init方法内只管控件内部的创建，但不管frame的初始化，因为外界调用的init方法不一定马上给frame赋值，所以第一次init是frame的值可能为nil 2.定义位置尺寸（Frame）。重写系统的-(void)layoutSubviews方法,这个方法方法专门用来布局子控件，一般在这里设置子控件的frame，当控件本身的尺寸发生改变的时候，系统会自动调用这个方法。重写此方法内一定要调用[super layoutSubviews] 3.设置数据。提供一个模型属性，重写模型属性的set方法，在set方法中取出模型属性，给对应的子控件赋值 在自定义控件内还可以添加其他更方便的初始化方法，可以参照apple官方的UIView等主要控件，还可以更高层次的封装，这个等以后再谈及。 1234567891011121314151617181920212223//重写-(instancetype)initWithFrame:(CGRect)frame方法//init方法内部会自动调用-(instancetype)initWithFrame:(CGRect)frame 方法，因此建议写这个方法，用于替代-(instancetype)init 方法-(instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super init]) &#123; //添加图片 UIImageView * iconView = [[UIImageView alloc]init]; iconView.backgroundColor = [UIColor grayColor]; [self addSubview:iconView]; //添加文字 UILabel * name = [[UILabel alloc]init]; name.backgroundColor = [UIColor greenColor]; name.font = [UIFont systemFontOfSize:15]; name.textAlignment = NSTextAlignmentCenter; [self addSubview:name]; &#125; return self;&#125; 1234567891011121314/** * 这个方法专门用来布局子控件，一般在这里设置子控件的frame * 当控件本身的尺寸发生改变的时候，系统会自动调用这个方 */-(void)layoutSubviews&#123; // 一定要调用super方法 [super layoutSubviews]; CGFloat shopW = self.frame.size.width; CGFloat shopH = self.frame.size.height; self.iconView.frame = CGRectMake(0, 0, shopW, shopW); self.name.frame = CGRectMake(0, shopW, shopW, shopH-shopW);&#125; 123456-(void)setShop:(CYXShop *)shop&#123; //赋值 _shop = shop; self.name.text = self.shop.name; self.iconView.image = [UIImage imageNamed:self.shop.icon];&#125; 补充： init和initWithFrame（一般在使用代码创建的时候调用 在调用init的时候，系统会默认调用一次initWithFrame；但在调用initWithFrame不会调用init；所以一般初始化自己的子控件一般都是放在initWithFrame ###给封装View设置数据的几种方式 （1）直接将属性暴漏在.h文件中：不好，影响封装性，不应该将自己的子控件暴漏在头文件中 （2）提供一个初始化方法 （3）根据tag设置子控件数据 因为子控件较少，所以设置比较方便。 控制器做的的太多了 （4）提供一个设置模型的方法，将模型传递过去（直接传递一个模型对象给View自己设置值） （5）提供一个属性，直接使用点语法赋值（最终采取的方法）]]></content>
    </entry>

    
  
  
</search>
